FUNCTION  <SNR>16_is_forbidden()
Called 11 times
Total time:   0.012844
 Self time:   0.000903

count  total (s)   self (s)
   11   0.000600   0.000484   if s:is_excluded_ft(&filetype)
                                return 1
                              endif
   11   0.000394   0.000105   if !s:get('excluded_regions_enabled')
                                return 0
                              endif
   11   0.011371   0.000107   let region = s:get_syn_name()
   11   0.000418   0.000146   return index(s:get('excluded_regions_list'), region) >= 0

FUNCTION  lfMru#record()
Called 1 time
Total time:   0.000879
 Self time:   0.000879

count  total (s)   self (s)
    1              0.000028     if a:name == '' || !filereadable(a:name)
                                    return
                                endif
                            
    1              0.000847     exec g:Lf_py 'mru.saveToCache(r"""'.a:name.'""")'

FUNCTION  <SNR>18_is_file_buffer()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000016   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  ale#sign#SetSigns()
Called 20 times
Total time:   0.351164
 Self time:   0.225960

count  total (s)   self (s)
   20              0.000076     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
   20   0.063253   0.000272     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
   20   0.008195   0.000224     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
   20   0.005746   0.000158     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
   20   0.037148   0.000252     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
   20   0.011946   0.000178     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
   20              0.000040     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
   26              0.000042     for l:command in l:command_list
    6              0.224294         silent! execute l:command
    6              0.000017     endfor
                            
                                " Reset the sign column color when there are no more errors.
   20              0.000046     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  ale_linters#python#mypy#Handle()
Called 19 times
Total time:   0.022968
 Self time:   0.001230

count  total (s)   self (s)
   19   0.018475   0.000142     let l:dir = s:GetDir(a:buffer)
                                " Look for lines like the following:
                                "
                                " file.py:4: error: No library stub file for module 'django.db'
                                "
                                " Lines like these should be ignored below:
                                "
                                " file.py:4: note: (Stub files are from https://github.com/python/typeshed)
   19              0.000040     let l:pattern = '\v^([a-zA-Z]?:?[^:]+):(\d+):?(\d+)?: (error|warning): (.+)$'
   19              0.000025     let l:output = []
                            
   35   0.002322   0.000189     for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    " Skip invalid syntax errors if the option is on.
   16   0.000507   0.000144         if l:match[5] is# 'invalid syntax'&& ale#Var(a:buffer, 'python_mypy_ignore_invalid_syntax')
                                        continue
                                    endif
                            
   16   0.001184   0.000275         call add(l:output, {   'filename': ale#path#GetAbsPath(l:dir, l:match[1]),   'lnum': l:match[2] + 0,   'col': l:match[3] + 0,   'type': l:match[4] is# 'error' ? 'E' : 'W',   'text': l:match[5],})
   16              0.000016     endfor
                            
   19              0.000019     return l:output

FUNCTION  ale#job#IsRunning()
Called 21 times
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
   21              0.000089     if has('nvim')
                                    try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
                                        call jobpid(a:job_id)
                                        return 1
                                    catch
                                    endtry
                                elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                                    return job_status(l:job) is# 'run'
                                endif
                            
   21              0.000019     return 0

FUNCTION  <SNR>119_CreateTemporaryFileForJob()
Called 21 times
Total time:   0.024481
 Self time:   0.003853

count  total (s)   self (s)
   21              0.000046     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
    1              0.000001         return 0
                                endif
                            
   20              0.000074     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
   20              0.001693     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
   20   0.000588   0.000168     call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
   20              0.001516     let l:lines = getbufline(a:buffer, 1, '$')
   20   0.020384   0.000176     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
   20              0.000049     return 1

FUNCTION  <SNR>125_has_fresh_changes()
Called 1 time
Total time:   0.000060
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000058   0.000024   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  lfMru#recordBuffer()
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000050     exec g:Lf_py 'mru.setBufferTimestamp('.a:bufNum.')'

FUNCTION  gitgutter#process_buffer()
Called 1 time
Total time:   0.009549
 Self time:   0.000774

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    1   0.001515   0.000139   if gitgutter#utility#is_active(a:bufnr)
    1   0.000200   0.000140     if a:force || s:has_fresh_changes(a:bufnr)
                            
    1              0.000004       let diff = ''
    1              0.000002       try
    1   0.007722   0.000383         let diff = gitgutter#diff#run_diff(a:bufnr, 0)
    1              0.000009       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    1              0.000003       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    1              0.000001     endif
    1              0.000000   endif

FUNCTION  <SNR>119_RunJob()
Called 21 times
Total time:   0.080037
 Self time:   0.010655

count  total (s)   self (s)
   21              0.000044     let l:command = a:options.command
   21              0.000034     let l:buffer = a:options.buffer
   21              0.000029     let l:linter = a:options.linter
   21              0.000035     let l:output_stream = a:options.output_stream
   21              0.000035     let l:next_chain_index = a:options.next_chain_index
   21              0.000036     let l:read_buffer = a:options.read_buffer
   21              0.000174     let l:info = g:ale_buffer_info[l:buffer]
                            
   21              0.000043     if empty(l:command)
                                    return 0
                                endif
                            
   21   0.003577   0.000260     let [l:temporary_file, l:command] = ale#command#FormatCommand(l:buffer, l:command, l:read_buffer)
                            
   21   0.025706   0.001225     if s:CreateTemporaryFileForJob(l:buffer, l:temporary_file)
                                    " If a temporary filename has been formatted in to the command, then
                                    " we do not need to send the Vim buffer to the command.
   20              0.000051         let l:read_buffer = 0
   20              0.000016     endif
                            
                                " Add a newline to commands which need it.
                                " This is only used for Flow for now, and is not documented.
   21              0.000040     if l:linter.add_newline
                                    if has('win32')
                                        let l:command = l:command . '; echo.'
                                    else
                                        let l:command = l:command . '; echo'
                                    endif
                                endif
                            
   21   0.002681   0.000213     let l:command = ale#job#PrepareCommand(l:buffer, l:command)
   21              0.000152     let l:job_options = {   'mode': 'nl',   'exit_cb': function('s:HandleExit'),}
                            
   21              0.000043     if l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                else
   21              0.000090         let l:job_options.out_cb = function('s:GatherOutput')
   21              0.000010     endif
                            
   21              0.000057     if get(g:, 'ale_run_synchronously') == 1
                                    " Find a unique Job value to use, which will be the same as the ID for
                                    " running commands synchronously. This is only for test code.
                                    let l:job_id = len(s:job_info_map) + 1
                            
                                    while has_key(s:job_info_map, l:job_id)
                                        let l:job_id += 1
                                    endwhile
                                else
   21   0.032430   0.001560         let l:job_id = ale#job#Start(l:command, l:job_options)
   21              0.000034     endif
                            
   21              0.000056     let l:status = 'failed'
                            
                                " Only proceed if the job is being run.
   21              0.000023     if l:job_id
                                    " Add the job to the list of jobs, so we can track them.
   21              0.000320         call add(l:info.job_list, l:job_id)
                            
   21              0.000254         if index(l:info.active_linter_list, l:linter.name) < 0
   21              0.000150             call add(l:info.active_linter_list, l:linter.name)
   21              0.000017         endif
                            
   21              0.000302         let l:status = 'started'
                                    " Store the ID for the job in the map to read back again.
   21              0.000406         let s:job_info_map[l:job_id] = {   'linter': l:linter,   'buffer': l:buffer,   'output': [],   'next_chain_index': l:next_chain_index,}
                            
   21   0.002542   0.001732         silent doautocmd <nomodeline> User ALEJobStarted
   21              0.000027     endif
                            
   21              0.000041     if g:ale_history_enabled
   21   0.008085   0.000649         call ale#history#Add(l:buffer, l:status, l:job_id, l:command)
   21              0.000027     endif
                            
   21              0.000087     if get(g:, 'ale_run_synchronously') == 1
                                    " Run a command synchronously if this test option is set.
                                    let s:job_info_map[l:job_id].output = systemlist(   type(l:command) == type([])   ?  join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])   : l:command)
                            
                                    call l:job_options.exit_cb(l:job_id, v:shell_error)
                                endif
                            
   21              0.000450     return l:job_id != 0

FUNCTION  airline#parts#iminsert()
Called 76 times
Total time:   0.000576
 Self time:   0.000576

count  total (s)   self (s)
   76              0.000207   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   76              0.000061   return ''

FUNCTION  ale#linter#Get()
Called 63 times
Total time:   0.027075
 Self time:   0.018633

count  total (s)   self (s)
   63              0.000166     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
  126              0.000717     for l:original_filetype in split(a:original_filetypes, '\.')
   63   0.005215   0.000530         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   63   0.001641   0.000634         let l:linter_names = s:GetLinterNames(l:original_filetype)
   63   0.003236   0.000486         let l:all_linters = ale#linter#GetAll(l:filetype)
   63              0.000114         let l:filetype_linters = []
                            
   63              0.000240         if type(l:linter_names) == type('') && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) == type([])
                                        " Select only the linters we or the user has specified.
  504              0.000617             for l:linter in l:all_linters
  441              0.001689                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
  756              0.001329                 for l:name in l:name_list
  441              0.001028                     if index(l:linter_names, l:name) >= 0
  126              0.000331                         call add(l:filetype_linters, l:linter)
  126              0.000125                         break
                                                endif
  315              0.000399                 endfor
  441              0.000374             endfor
   63              0.000094         endif
                            
   63              0.000212         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   63              0.000502     endfor
                            
   63              0.000147     let l:name_list = []
   63              0.000108     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
  189              0.000348     for l:linter in reverse(l:possibly_duplicated_linters)
  126              0.000318         if index(l:name_list, l:linter.name) < 0
  126              0.000328             call add(l:name_list, l:linter.name)
  126              0.000297             call add(l:combined_linters, l:linter)
  126              0.000083         endif
  126              0.000109     endfor
                            
   63              0.000153     return reverse(l:combined_linters)

FUNCTION  <SNR>137_SetListsImpl()
Called 20 times
Total time:   0.047844
 Self time:   0.005228

count  total (s)   self (s)
   20              0.001288     let l:title = expand('#' . a:buffer . ':p')
                            
   20              0.000046     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
   20   0.000398   0.000219         let l:id = s:BufWinId(a:buffer)
                            
   20              0.000086         if has('nvim')
                                        call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                    else
   20   0.041947   0.001601             call setloclist(l:id, s:FixList(a:buffer, a:loclist))
   20              0.000131             call setloclist(l:id, [], 'r', {'title': l:title})
   20              0.000014         endif
   20              0.000006     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
   20   0.000925   0.000202     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert '
                                    endif
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
   20   0.000269   0.000095     if !ale#engine#IsCheckingBuffer(a:buffer)
   19   0.001325   0.000131         call s:CloseWindowIfNeeded(a:buffer)
   19              0.000012     endif

FUNCTION  <SNR>135_GetCounts()
Called 152 times
Total time:   0.002963
 Self time:   0.002963

count  total (s)   self (s)
  152              0.000880     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
  152              0.000508     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
  152              0.000308     return g:ale_buffer_info[a:buffer].count

FUNCTION  ale#python#FindProjectRootIni()
Called 39 times
Total time:   0.027578
 Self time:   0.019135

count  total (s)   self (s)
  351   0.011205   0.002762     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
                                    " If you change this, update ale-python-root documentation.
  312              0.014948         if filereadable(l:path . '/MANIFEST.in')|| filereadable(l:path . '/setup.cfg')|| filereadable(l:path . '/pytest.ini')|| filereadable(l:path . '/tox.ini')|| filereadable(l:path . '/mypy.ini')|| filereadable(l:path . '/pycodestyle.cfg')|| filereadable(l:path . '/flake8.cfg')
                                        return l:path
                                    endif
  312              0.000215     endfor
                            
   39              0.000041     return ''

FUNCTION  ale_linters#python#mypy#GetExecutable()
Called 40 times
Total time:   0.154572
 Self time:   0.000470

count  total (s)   self (s)
   40   0.154544   0.000442     return ale#python#FindExecutable(a:buffer, 'python_mypy', ['mypy'])

FUNCTION  <SNR>136_GroupLoclistItems()
Called 20 times
Total time:   0.005588
 Self time:   0.005588

count  total (s)   self (s)
   20              0.000034     let l:grouped_items = []
   20              0.000030     let l:last_lnum = -1
                            
  476              0.000362     for l:obj in a:loclist
  456              0.000476         if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
  456              0.000469         if l:obj.lnum != l:last_lnum
  356              0.000624             call add(l:grouped_items, [])
  356              0.000187         endif
                            
  456              0.000934         call add(l:grouped_items[-1], l:obj)
  456              0.000533         let l:last_lnum = l:obj.lnum
  456              0.000533     endfor
                            
   20              0.000024     return l:grouped_items

FUNCTION  airline#statusline()
Called 76 times
Total time:   0.001866
 Self time:   0.001866

count  total (s)   self (s)
   76              0.000944   if has_key(s:contexts, a:winnr)
   76              0.000738     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
Called 76 times
Total time:   0.142274
 Self time:   0.007498

count  total (s)   self (s)
   76              0.000336   let context = s:contexts[a:winnr]
                            
   76              0.000304   if get(w:, 'airline_active', 1)
   76              0.000252     let l:m = mode()
   76              0.000145     if l:m ==# "i"
   71              0.000146       let l:mode = ['insert']
   71              0.000083     elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
    5              0.000016       let l:mode = ['normal']
    5              0.000006     endif
   76              0.000629     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   76              0.000070   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   76              0.000265   if g:airline_detect_modified && &modified
   74              0.000314     call add(l:mode, 'modified')
   74              0.000050   endif
                            
   76              0.000197   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   76              0.000335   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   76              0.000156   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
   76              0.000121   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
   76              0.000657   let mode_string = join(l:mode)
   76              0.000279   if get(w:, 'airline_lastmode', '') != mode_string
    5   0.002350   0.000110     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    5   0.132672   0.000136     call airline#highlighter#highlight(l:mode, context.bufnr)
    5              0.000020     let w:airline_lastmode = mode_string
    5              0.000003   endif
                            
   76              0.000077   return ''

FUNCTION  airline#util#append()
Called 532 times
Total time:   0.005553
 Self time:   0.005553

count  total (s)   self (s)
  532              0.001239   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  532              0.001719   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  532              0.001413   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  ale#events#QuitRecently()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    1              0.000003     return l:time && ale#util#ClockMilliseconds() - l:time < 1000

FUNCTION  airline#themes#get_highlight()
Called 126 times
Total time:   0.014415
 Self time:   0.000884

count  total (s)   self (s)
  126   0.014381   0.000850   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  ale#linter#ResolveFiletype()
Called 63 times
Total time:   0.004685
 Self time:   0.001014

count  total (s)   self (s)
   63   0.004240   0.000569     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   63              0.000213     if type(l:filetype) != type([])
   63              0.000112         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  ale#highlight#RemoveHighlights()
Called 20 times
Total time:   0.009961
 Self time:   0.009961

count  total (s)   self (s)
  899              0.002580     for l:match in getmatches()
  879              0.004007         if l:match.group =~# '^ALE'
  456              0.000963             call matchdelete(l:match.id)
  456              0.000253         endif
  879              0.001136     endfor

FUNCTION  <SNR>131_Pyeval()
Called 189 times
Total time:   0.042639
 Self time:   0.042639

count  total (s)   self (s)
  189              0.000402   if s:using_python3
  189              0.041943     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  ale#sign#FindCurrentSigns()
Called 20 times
Total time:   0.062981
 Self time:   0.000414

count  total (s)   self (s)
   20   0.001035   0.000173     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
   20   0.061881   0.000176     return ale#sign#ParseSigns(l:line_list)

FUNCTION  <SNR>94_get_hunks_gitgutter()
Called 76 times
Total time:   0.004249
 Self time:   0.001251

count  total (s)   self (s)
   76   0.001066   0.000605   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
   76   0.002958   0.000421   return GitGutterGetHunkSummary()

FUNCTION  ale#statusline#Count()
Called 152 times
Total time:   0.004270
 Self time:   0.001307

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  152   0.004090   0.001127     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>131_OnInsertLeave()
Called 2 times
Total time:   0.006173
 Self time:   0.002808

count  total (s)   self (s)
    2   0.000132   0.000026   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    2              0.000009   call timer_stop( s:pollers.completion.id )
    2              0.000002   let s:force_semantic = 0
    2              0.000008   let s:completion = s:default_completion
                            
    2   0.003304   0.000045   call s:OnFileReadyToParse()
    2              0.002679   exec s:python_command "ycm_state.OnInsertLeave()"
    2              0.000015   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  ale#engine#IsExecutable()
Called 21 times
Total time:   0.000349
 Self time:   0.000349

count  total (s)   self (s)
   21              0.000046     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
   21              0.000094     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   21              0.000029     if l:result isnot v:null
   21              0.000024         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result

FUNCTION  ale#sign#GetSignName()
Called 356 times
Total time:   0.016467
 Self time:   0.011198

count  total (s)   self (s)
  356              0.000656     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
  812              0.001019     for l:item in a:sublist
  456   0.007675   0.002406         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
  456              0.000651         if l:item_priority > l:priority
  356              0.000507             let l:priority = l:item_priority
  356              0.000205         endif
  456              0.000277     endfor
                            
  356              0.000545     if l:priority is# g:ale#util#error_priority
   16              0.000018         return 'ALEErrorSign'
                                endif
                            
  340              0.000438     if l:priority is# g:ale#util#warning_priority
  340              0.000353         return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>16_is_cr_expansion()
Called 7 times
Total time:   0.000744
 Self time:   0.000537

count  total (s)   self (s)
    7              0.000034   let nchar = getline(line('.')-1)[-1:]
    7              0.000332   let schar = matchstr(getline(line('.')+1), '^\s*\zs\S')
    7              0.000034   let isEmpty = a:0 ? getline('.') =~ '^\s*$' : empty(getline('.'))
    7   0.000176   0.000062   if index(s:get('left_delims'), nchar) > -1 && index(s:get('left_delims'), nchar)    == index(s:get('right_delims'), schar) && isEmpty
                                return 1
                              elseif index(s:get('quotes_list'), nchar) > -1 && index(s:get('quotes_list'), nchar)    == index(s:get('quotes_list'), schar) && isEmpty
                                return 1
                              else
    7              0.000004     return 0
                              endif

FUNCTION  ale#statusline#Update()
Called 20 times
Total time:   0.007509
 Self time:   0.007369

count  total (s)   self (s)
   20              0.000110     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
   20              0.000363     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
   20   0.000285   0.000145     let l:count = s:CreateCountDict()
   20              0.000052     let l:count.total = len(l:loclist)
                            
  476              0.000376     for l:entry in l:loclist
  456              0.000537         if l:entry.type is# 'W'
  440              0.000903             if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                                        else
  440              0.000442                 let l:count.warning += 1
  440              0.000215             endif
  440              0.000347         elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                                    else
   16              0.000015             let l:count.error += 1
   16              0.000007         endif
  456              0.000300     endfor
                            
                                " Set keys for backwards compatibility.
   20              0.000066     let l:count[0] = l:count.error + l:count.style_error
   20              0.000053     let l:count[1] = l:count.total - l:count[0]
                            
   20              0.000162     let g:ale_buffer_info[a:buffer].count = l:count

FUNCTION  airline#highlighter#highlight()
Called 5 times
Total time:   0.132536
 Self time:   0.017115

count  total (s)   self (s)
    5              0.000013   let bufnr = a:0 ? a:1 : ''
    5              0.000018   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    5              0.000062   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    5              0.000015   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   14              0.000021   for mode in mapped
    9              0.000023     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
    9              0.000052     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    9              0.000030       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  133              0.000346       for kvp in items(dict)
  124              0.000277         let mode_colors = kvp[1]
  124              0.000210         let name = kvp[0]
  124              0.000344         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
  124   0.030279   0.000939         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  372              0.000719         for accent in keys(s:accents)
  248              0.000628           if !has_key(p.accents, accent)
                                        continue
                                      endif
  248              0.000963           let colors = copy(mode_colors)
  248              0.000702           if p.accents[accent][0] != ''
  124              0.000328             let colors[0] = p.accents[accent][0]
  124              0.000083           endif
  248              0.000525           if p.accents[accent][2] != ''
                                        let colors[2] = p.accents[accent][2]
                                      endif
  248              0.000452           if len(colors) >= 5
  248              0.000823             let colors[4] = get(p.accents[accent], 4, '')
  248              0.000177           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  248   0.057923   0.002152           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  248              0.000354         endfor
  124              0.000200       endfor
                            
                                  " TODO: optimize this
   72              0.000204       for sep in items(s:separators)
   63   0.030919   0.000609         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   63              0.000086       endfor
    9              0.000009     endif
    9              0.000023   endfor

FUNCTION  <SNR>133_reset_summary()
Called 1 time
Total time:   0.000028
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000027   0.000008   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>16_get_char()
Called 44 times
Total time:   0.001916
 Self time:   0.001916

count  total (s)   self (s)
   44              0.000127   let idx = col('.') - 1
   44              0.000087   if !a:0 || (a:0 && a:1 >= 0)
                                " Get char from cursor.
   22              0.000056     let line = getline('.')[idx :]
   22              0.000028     let pos = a:0 ? a:1 : 0
   22              0.000205     return matchstr(line, '^'.repeat('.', pos).'\zs.')
                              endif
                              " Get char behind cursor.
   22              0.000076   let line = getline('.')[: idx - 1]
   22              0.000041   let pos = 0 - (1 + a:1)
   22              0.001089   return matchstr(line, '.\ze'.repeat('.', pos).'$')

FUNCTION  <SNR>16_get_syn_name()
Called 11 times
Total time:   0.011264
 Self time:   0.011264

count  total (s)   self (s)
   11              0.000039   let col = col('.')
   11              0.000029   if  col == col('$')
    8              0.000017     let col = col - 1
    8              0.000005   endif
   11              0.011150   return synIDattr(synIDtrans(synID(line('.'), col, 1)), 'name')

FUNCTION  ale#FileTooLarge()
Called 86 times
Total time:   0.000909
 Self time:   0.000909

count  total (s)   self (s)
   86              0.000494     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   86              0.000311     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#highlight#UpdateHighlights()
Called 20 times
Total time:   0.027337
 Self time:   0.015235

count  total (s)   self (s)
   20              0.000131     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
   20   0.010166   0.000205     call ale#highlight#RemoveHighlights()
                            
  476              0.000420     for l:item in l:item_list
  456              0.000578         if l:item.type is# 'W'
  440              0.000953             if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
  440              0.000522                 let l:group = 'ALEWarning'
  440              0.000224             endif
  440              0.000358         elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
   16              0.000018             let l:group = 'ALEError'
   16              0.000007         endif
                            
  456              0.000527         let l:line = l:item.lnum
  456              0.000475         let l:col = l:item.col
  456              0.000980         let l:end_line = get(l:item, 'end_lnum', l:line)
  456              0.000923         let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
  456   0.005980   0.003839         call map(   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),   'matchaddpos(l:group, v:val)')
  456              0.000745     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
   20              0.000024     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call matchaddpos(l:group, [l:item.lnum])
                                        endif
                                    endfor
                                endif

FUNCTION  airline#parts#filetype()
Called 76 times
Total time:   0.000503
 Self time:   0.000503

count  total (s)   self (s)
   76              0.000410   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  <SNR>124_VimCloseCallback()
Called 21 times
Total time:   0.479496
 Self time:   0.002059

count  total (s)   self (s)
   21              0.000272     let l:job = ch_getjob(a:channel)
   21   0.001347   0.000307     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
   21              0.000131     let l:info = get(s:job_map, l:job_id, {})
                            
   21              0.000053     if empty(l:info)
                                    return
                                endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
   21   0.456702   0.000528     if job_status(l:job) is# 'dead'
   21              0.000017         try
   21              0.000075             if !empty(l:info) && has_key(l:info, 'exit_cb')
   21   0.020479   0.000256                 call ale#util#GetFunction(l:info.exit_cb)(l:job_id, get(l:info, 'exit_code', 1))
   21              0.000010             endif
   21              0.000011         finally
                                        " Automatically forget about the job after it's done.
   21              0.000048             if has_key(s:job_map, l:job_id)
    1              0.000004                 call remove(s:job_map, l:job_id)
    1              0.000000             endif
   21              0.000018         endtry
   21              0.000012     endif

FUNCTION  <SNR>132_FindItemAtCursor()
Called 3 times
Total time:   0.000686
 Self time:   0.000147

count  total (s)   self (s)
    3              0.000008     let l:buf = bufnr('')
    3              0.000020     let l:info = get(g:ale_buffer_info, l:buf, {})
    3              0.000013     let l:loclist = get(l:info, 'loclist', [])
    3              0.000007     let l:pos = getcurpos()
    3   0.000604   0.000065     let l:index = ale#util#BinarySearch(l:loclist, l:buf, l:pos[1], l:pos[2])
    3              0.000012     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    3              0.000009     return [l:info, l:loc]

FUNCTION  <SNR>16_is_excluded_ft()
Called 11 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
   11              0.000084   if !exists("g:delimitMate_excluded_ft")
   11              0.000022     return 0
                              endif
                              return index(split(g:delimitMate_excluded_ft, ','), a:ft, 0, 1) >= 0

FUNCTION  ale#python#FindProjectRoot()
Called 39 times
Total time:   0.037879
 Self time:   0.002601

count  total (s)   self (s)
   39   0.027895   0.000317     let l:ini_root = ale#python#FindProjectRootIni(a:buffer)
                            
   39              0.000086     if !empty(l:ini_root)
                                  return l:ini_root
                                endif
                            
   39   0.009170   0.001470     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
   39              0.000435         if !filereadable(l:path . '/__init__.py')
   39              0.000067             return l:path
                                    endif
                                endfor
                            
                                return ''

FUNCTION  gitgutter#async#execute()
Called 1 time
Total time:   0.002174
 Self time:   0.002081

count  total (s)   self (s)
    1   0.000176   0.000095   call gitgutter#debug#log('[async] '.a:cmd)
                            
    1              0.000010   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    1   0.000108   0.000096   let command = s:build_command(a:cmd)
                            
    1              0.000007   if has('nvim')
                                call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
    1              0.001817     call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
    1              0.000004   endif

FUNCTION  <SNR>109_ApplyPartialTimer()
Called 18 times
Total time:   0.043841
 Self time:   0.000909

count  total (s)   self (s)
   18              0.000235     if has_key(s:partial_timers, a:timer_id)
   18              0.000208         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
   18   0.043342   0.000410         call call(l:Callback, [a:timer_id] + l:args)
   18              0.000008     endif

FUNCTION  SaveCurrentLength()
Called 1 time
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    1              0.000002 python3 << endOfPython
                            import vim
                            line = vim.current.line
                            vim.command("let b:autoformat_lastlength = {}".format(len(line)))
                            endOfPython
    1              0.000002 return ''

FUNCTION  <SNR>16_joinUndo()
Called 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    3              0.000012   if v:version < 704 || ( v:version == 704 && !has('patch849') )
                                return ''
                              endif
    3              0.000008   return "\<C-G>U"

FUNCTION  ale#history#RememberOutput()
Called 20 times
Total time:   0.000598
 Self time:   0.000176

count  total (s)   self (s)
   20   0.000533   0.000111     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
   20              0.000041     let l:obj.output = a:output

FUNCTION  ale#engine#ManageDirectory()
Called 20 times
Total time:   0.000420
 Self time:   0.000177

count  total (s)   self (s)
   20   0.000322   0.000079     call ale#engine#InitBufferInfo(a:buffer)
   20              0.000087     call add(g:ale_buffer_info[a:buffer].temporary_directory_list, a:directory)

FUNCTION  ale#ShouldDoNothing()
Called 86 times
Total time:   0.009194
 Self time:   0.007031

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                            
                                " Do nothing if ALE is disabled.
   86              0.000558     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   86              0.000338     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
   86              0.000385     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   86              0.000161     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
   86              0.000561     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
   86              0.000358     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
   86              0.000488     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   86              0.000141     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
   86   0.001639   0.000385     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
   86   0.001347   0.000438     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   86              0.000805     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
   86              0.000069     return 0

FUNCTION  airline#extensions#ale#get_error()
Called 76 times
Total time:   0.010080
 Self time:   0.000479

count  total (s)   self (s)
   76   0.010049   0.000448   return airline#extensions#ale#get('error')

FUNCTION  ale_linters#python#pylint#Handle()
Called 1 time
Total time:   0.004772
 Self time:   0.000463

count  total (s)   self (s)
                                " Matches patterns like the following:
                                "
                                " test.py:4:4: W0101 (unreachable) Unreachable code
    1              0.000003     let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):(\d+): ([[:alnum:]]+) \(([^(]*)\) (.*)$'
    1              0.000001     let l:output = []
                            
   23   0.004376   0.000067     for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    "let l:failed = append(0, l:match)
   22              0.000035         let l:code = l:match[3]
                            
   22              0.000045         if (l:code is# 'C0303') && !ale#Var(a:buffer, 'warn_about_trailing_whitespace')
                                        " Skip warnings for trailing whitespace if the option is off.
                                        continue
                                    endif
                            
   22              0.000026         if l:code is# 'I0011'
                                        " Skip 'Locally disabling' message
                                         continue
                                    endif
                            
   22              0.000153         call add(l:output, {   'lnum': l:match[1] + 0,   'col': l:match[2] + 1,   'text': l:match[5],   'code': l:match[4],   'type': l:code[:0] is# 'E' ? 'E' : 'W',})
   22              0.000010     endfor
                            
    1              0.000001     return l:output

FUNCTION  ale#Var()
Called 603 times
Total time:   0.016023
 Self time:   0.016023

count  total (s)   self (s)
  603              0.003165     let l:nr = str2nr(a:buffer)
  603              0.001662     let l:full_name = 'ale_' . a:variable_name
                            
  603              0.001386     if bufexists(l:nr)
  603              0.001769         let l:vars = getbufvar(l:nr, '')
  603              0.001158     elseif has_key(g:, 'ale_fix_buffer_data')
                                    let l:vars = get(g:ale_fix_buffer_data, l:nr, {'vars': {}}).vars
                                else
                                    let l:vars = {}
                                endif
                            
  603              0.002383     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  delimitMate#IsEmptyPair()
Called 8 times
Total time:   0.000283
 Self time:   0.000190

count  total (s)   self (s)
    8              0.000080   if strlen(substitute(a:str, ".", "x", "g")) != 2
    5              0.000005     return 0
                              endif
    3   0.000079   0.000030   let idx = index(s:get('left_delims'), matchstr(a:str, '^.'))
    3   0.000027   0.000014   if idx > -1 && s:get('right_delims')[idx] == matchstr(a:str, '.$')
    1              0.000001     return 1
                              endif
    2   0.000062   0.000031   let idx = index(s:get('quotes_list'), matchstr(a:str, '^.'))
    2              0.000006   if idx > -1 && s:get('quotes_list')[idx] == matchstr(a:str, '.$')
                                return 1
                              endif
    2              0.000002   return 0

FUNCTION  gitgutter#utility#cd_cmd()
Called 1 time
Total time:   0.000876
 Self time:   0.000267

count  total (s)   self (s)
    1   0.000395   0.000209   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    1   0.000479   0.000056   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>131_AllowedToCompleteInBuffer()
Called 89 times
Total time:   0.005280
 Self time:   0.004763

count  total (s)   self (s)
   89              0.000831   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
   89              0.000668   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
                                return 0
                              endif
                            
   89   0.001009   0.000492   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
   89              0.000855   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
   89              0.000443   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
   89              0.000186   let allowed = whitelist_allows && blacklist_allows
   89              0.000086   if allowed
   89              0.000363     let s:previous_allowed_buffer_number = bufnr( a:buffer )
   89              0.000070   endif
   89              0.000095   return allowed

FUNCTION  delimitMate#ParenDelim()
Called 3 times
Total time:   0.004961
 Self time:   0.000501

count  total (s)   self (s)
    3   0.000293   0.000082   let left = s:get('left_delims')[index(s:get('right_delims'),a:right)]
    3   0.003984   0.000065   if s:is_forbidden(a:right)
                                return left
                              endif
                              " Try to balance matchpairs
    3   0.000096   0.000035   if s:get('balance_matchpairs') && s:balance_matchpairs(a:right) < 0
                                return left
                              endif
    3              0.000012   let line = getline('.')
    3              0.000009   let col = col('.')-2
    3   0.000072   0.000014   if s:get('smart_matchpairs') != ''
    3   0.000113   0.000056     let smart_matchpairs = substitute(s:get('smart_matchpairs'), '\\!', left, 'g')
    3              0.000023     let smart_matchpairs = substitute(smart_matchpairs, '\\#', a:right, 'g')
    3              0.000043     if line[col+1:] =~ smart_matchpairs
                                  return left
                                endif
    3              0.000003   endif
    3   0.000099   0.000038   if len(line) == (col + 1) && s:get('insert_eol_marker') == 1
    3   0.000069   0.000013     let tail = s:get('eol_marker')
    3              0.000001   else
                                let tail = ''
                              endif
    3   0.000105   0.000068   return left . a:right . tail . repeat(s:joinUndo() . "\<Left>", len(split(tail, '\zs')) + 1)

FUNCTION  SimpylFold#Recache()
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000011     if exists('b:SimpylFold_cache')
                                    unlet b:SimpylFold_cache
                                endif

FUNCTION  <SNR>18_dir()
Called 2 times
Total time:   0.000954
 Self time:   0.000176

count  total (s)   self (s)
    2   0.000952   0.000174   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>122_FindHistoryItem()
Called 40 times
Total time:   0.001188
 Self time:   0.000728

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   42   0.000856   0.000396     for l:obj in reverse(ale#history#Get(a:buffer))
   42              0.000084         if l:obj.job_id == a:job_id
   40              0.000073             return l:obj
                                    endif
    2              0.000002     endfor
                            
                                return {}

FUNCTION  <SNR>131_Complete()
Called 55 times
Total time:   0.001548
 Self time:   0.001190

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
   55              0.000341   if s:completion.start_column > col( '.' ) || empty( s:completion.candidates )
   41   0.000433   0.000190     call s:CloseCompletionMenu()
   41              0.000029   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects the
                                " first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim to
                                " deselect the first candidate and in turn preserve the user's current text
                                " until he explicitly chooses to replace it with a completion.
   14   0.000261   0.000146     call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
   14              0.000012   endif

FUNCTION  <SNR>16_is_space_expansion()
Called 7 times
Total time:   0.001834
 Self time:   0.000354

count  total (s)   self (s)
    7              0.000016   if col('.') > 2
    7   0.000632   0.000038     let pchar = s:get_char(-2)
    7   0.000179   0.000042     let nchar = s:get_char(1)
    7   0.000572   0.000091     let isSpaces = (s:get_char(-1)   == s:get_char(0) && s:get_char(-1) == " ")
                            
    7   0.000232   0.000071     if index(s:get('left_delims'), pchar) > -1 && index(s:get('left_delims'), pchar)   == index(s:get('right_delims'), nchar) && isSpaces
                                  return 1
                                elseif index(s:get('quotes_list'), pchar) > -1 && index(s:get('quotes_list'), pchar)   == index(s:get('quotes_list'), nchar) && isSpaces
                                  return 1
                                endif
    7              0.000003   endif
    7              0.000003   return 0

FUNCTION  <SNR>97_check_mixed_indent()
Called 1 time
Total time:   0.033659
 Self time:   0.033659

count  total (s)   self (s)
    1              0.000005   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000001   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.033644     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>137_BufWinId()
Called 20 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
   20              0.000164     return exists('*bufwinid') ? bufwinid(str2nr(a:buffer)) : 0

FUNCTION  <SNR>136_UpdateLineNumbers()
Called 20 times
Total time:   0.007971
 Self time:   0.007031

count  total (s)   self (s)
   20              0.000035     let l:line_map = {}
   20              0.000030     let l:line_numbers_changed = 0
                            
  376              0.000492     for [l:line, l:sign_id, l:name] in a:current_sign_list
  356              0.000804         let l:line_map[l:sign_id] = l:line
  356              0.000263     endfor
                            
  476              0.000411     for l:item in a:loclist
  456              0.000497         if l:item.bufnr == a:buffer
  456              0.001404             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
  456              0.000603             if l:lnum && l:item.lnum != l:lnum
    2              0.000002                 let l:item.lnum = l:lnum
    2              0.000003                 let l:line_numbers_changed = 1
    2              0.000001             endif
  456              0.000247         endif
  456              0.000558     endfor
                            
                                " When the line numbers change, sort the list again
   20              0.000027     if l:line_numbers_changed
    1   0.001015   0.000075         call sort(a:loclist, 'ale#util#LocItemCompare')
    1              0.000001     endif

FUNCTION  <SNR>96_airline_ale_count()
Called 152 times
Total time:   0.000413
 Self time:   0.000413

count  total (s)   self (s)
  152              0.000345   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  ale#cursor#EchoCursorWarning()
Called 23 times
Total time:   0.006587
 Self time:   0.000239

count  total (s)   self (s)
   23   0.006557   0.000209     return ale#CallWithCooldown('dont_echo_until', function('s:EchoImpl'), [])

FUNCTION  <SNR>131_SendKeys()
Called 19 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
                              " By default keys are added to the end of the typeahead buffer. If there are
                              " already keys in the buffer, they will be processed first and may change the
                              " state that our keys combination was sent for (e.g. <C-X><C-U><C-P> in normal
                              " mode instead of insert mode or <C-e> outside of completion mode). We avoid
                              " that by inserting the keys at the start of the typeahead buffer with the 'i'
                              " option. Also, we don't want the keys to be remapped to something else so we
                              " add the 'n' option.
   19              0.000088   call feedkeys( a:keys, 'in' )

FUNCTION  ale#GetLocItemMessage()
Called 459 times
Total time:   0.029299
 Self time:   0.029299

count  total (s)   self (s)
  459              0.000801     let l:msg = a:format_string
  459              0.000786     let l:severity = g:ale_echo_msg_warning_str
  459              0.001143     let l:code = get(a:item, 'code', '')
  459              0.001018     let l:type = get(a:item, 'type', 'E')
  459              0.001258     let l:linter_name = get(a:item, 'linter_name', '')
  459              0.001462     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
  459              0.000609     if l:type is# 'E'
   19              0.000034         let l:severity = g:ale_echo_msg_error_str
   19              0.000018     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
  459              0.003188     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
  459              0.002803     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
  459              0.008853     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
  459              0.002833     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
  459              0.000557     return l:msg

FUNCTION  <SNR>132_StopCursorTimer()
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000006     if s:cursor_timer != -1
    2              0.000008         call timer_stop(s:cursor_timer)
    2              0.000006         let s:cursor_timer = -1
    2              0.000002     endif

FUNCTION  <SNR>137_ShouldOpen()
Called 39 times
Total time:   0.001286
 Self time:   0.000456

count  total (s)   self (s)
   39   0.001023   0.000193     let l:val = ale#Var(a:buffer, 'open_list')
   39              0.000128     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
   39              0.000087     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  ale#job#Stop()
Called 21 times
Total time:   0.001740
 Self time:   0.001285

count  total (s)   self (s)
   21              0.000187     if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
   21              0.000083     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
                                    silent! call jobstop(a:job_id)
                                else
   21              0.000061         let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
   21              0.000085         if ch_status(job_getchannel(l:job)) is# 'open'
    1              0.000006             call ch_close_in(job_getchannel(l:job))
    1              0.000001         endif
                            
                                    " Ask nicely for the job to stop.
   21              0.000241         call job_stop(l:job)
                            
   21   0.000599   0.000144         if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
   21              0.000013     endif

FUNCTION  ale#engine#InitBufferInfo()
Called 40 times
Total time:   0.000578
 Self time:   0.000578

count  total (s)   self (s)
   40              0.000159     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'active_linter_list': [],   'loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],}
                            
                                    return 1
                                endif
                            
   40              0.000038     return 0

FUNCTION  airline#util#shorten()
Called 152 times
Total time:   0.002570
 Self time:   0.002570

count  total (s)   self (s)
  152              0.000787   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
  152              0.000179     return a:text
                              endif

FUNCTION  <SNR>70_Highlight_Matching_Pair()
Called 85 times
Total time:   0.045261
 Self time:   0.045261

count  total (s)   self (s)
                              " Remove any previous match.
   85              0.000447   if exists('w:paren_hl_on') && w:paren_hl_on
   13              0.000094     silent! call matchdelete(3)
   13              0.000024     let w:paren_hl_on = 0
   13              0.000013   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   85              0.000364   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   85              0.000218   let c_lnum = line('.')
   85              0.000182   let c_col = col('.')
   85              0.000093   let before = 0
                            
   85              0.000212   let text = getline(c_lnum)
   85              0.005728   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   85              0.000180   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   85              0.000383     let [c_before, c] = matches[1:2]
   85              0.000048   endif
   85              0.003321   let plist = split(&matchpairs, '.\zs[:,]')
   85              0.000325   let i = index(plist, c)
   85              0.000093   if i < 0
                                " not found, in Insert mode try character before the cursor
   73              0.000262     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   72              0.000175       let before = strlen(c_before)
   72              0.000094       let c = c_before
   72              0.000149       let i = index(plist, c)
   72              0.000046     endif
   73              0.000063     if i < 0
                                  " not found, nothing to do
   71              0.000060       return
                                endif
    2              0.000002   endif
                            
                              " Figure out the arguments for searchpairpos().
   14              0.000016   if i % 2 == 0
    2              0.000006     let s_flags = 'nW'
    2              0.000009     let c2 = plist[i + 1]
    2              0.000003   else
   12              0.000017     let s_flags = 'nbW'
   12              0.000015     let c2 = c
   12              0.000029     let c = plist[i - 1]
   12              0.000005   endif
   14              0.000019   if c == '['
    2              0.000002     let c = '\['
    2              0.000000     let c2 = '\]'
    2              0.000000   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   14              0.000013   if before > 0
    2              0.000007     let has_getcurpos = exists("*getcurpos")
    2              0.000002     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    2              0.000005       let save_cursor = getcurpos()
    2              0.000002     else
                                  let save_cursor = winsaveview()
                                endif
    2              0.000006     call cursor(c_lnum, c_col - before)
    2              0.000001   endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
   14              0.000056   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
   14              0.014549   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
   14              0.000049   let stoplinebottom = line('w$')
   14              0.000036   let stoplinetop = line('w0')
   14              0.000022   if i % 2 == 0
    2              0.000007     let stopline = stoplinebottom
    2              0.000002   else
   12              0.000023     let stopline = stoplinetop
   12              0.000006   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   14              0.000046   if mode() == 'i' || mode() == 'R'
   12              0.000058     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   12              0.000009   else
    2              0.000011     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000002   endif
   14              0.000015   try
   14              0.014585     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   14              0.000026   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   14              0.000019   if before > 0
    2              0.000002     if has_getcurpos
    2              0.000006       call setpos('.', save_cursor)
    2              0.000001     else
                                  call winrestview(save_cursor)
                                endif
    2              0.000000   endif
                            
                              " If a match is found setup match highlighting.
   14              0.000034   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   14              0.000039     if exists('*matchaddpos')
   14              0.000185       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
   14              0.000007     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
   14              0.000026     let w:paren_hl_on = 1
   14              0.000008   endif

FUNCTION  ale#engine#IsCheckingBuffer()
Called 60 times
Total time:   0.000590
 Self time:   0.000590

count  total (s)   self (s)
   60              0.000281     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   60              0.000251     return !empty(get(l:info, 'active_linter_list', []))

FUNCTION  <SNR>131_CloseCompletionMenu()
Called 84 times
Total time:   0.000550
 Self time:   0.000509

count  total (s)   self (s)
   84              0.000185   if pumvisible()
    5   0.000068   0.000027     call s:SendKeys( "\<C-e>" )
    5              0.000004   endif

FUNCTION  <SNR>137_FixList()
Called 20 times
Total time:   0.040346
 Self time:   0.010811

count  total (s)   self (s)
   20   0.000694   0.000168     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
   20              0.000036     let l:new_list = []
                            
  476              0.000538     for l:item in a:list
  456              0.002049         let l:fixed_item = copy(l:item)
                            
  456   0.032172   0.003163         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
  456              0.000586         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
  456              0.001101         call add(l:new_list, l:fixed_item)
  456              0.001024     endfor
                            
   20              0.000023     return l:new_list

FUNCTION  <SNR>110_GetAliasedFiletype()
Called 63 times
Total time:   0.003671
 Self time:   0.003671

count  total (s)   self (s)
   63              0.000783     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List.
   63              0.000249     if type(l:buffer_aliases) is type([])
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
  252              0.000645     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
  189              0.000539         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
  189              0.000170     endfor
                            
   63              0.000097     return a:original_filetype

FUNCTION  airline#extensions#ale#get()
Called 152 times
Total time:   0.023522
 Self time:   0.007875

count  total (s)   self (s)
  152              0.000565   if !exists(':ALELint')
                                return ''
                              endif
                            
  152              0.000338   let is_err = a:type ==# 'error'
  152              0.000371   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
  152              0.000248   let is_err = a:type ==# 'error'
  152   0.005181   0.000911   let counts = ale#statusline#Count(bufnr(''))
  152              0.000317   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
  152              0.000655   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
  152              0.000359     let errors = counts.error + counts.style_error
  152              0.000306     let num = is_err ? errors : counts.total - errors
  152              0.000096   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
  152              0.000206   if s:show_line_numbers == 1
  152   0.013518   0.002141     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  <SNR>131_DisableOnLargeFile()
Called 89 times
Total time:   0.000517
 Self time:   0.000517

count  total (s)   self (s)
   89              0.000303   if exists( 'b:ycm_largefile' )
   89              0.000141     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  ale#job#ParseVim8ProcessID()
Called 108 times
Total time:   0.006734
 Self time:   0.006734

count  total (s)   self (s)
  108              0.006468     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  airline#util#wrap()
Called 608 times
Total time:   0.003321
 Self time:   0.003321

count  total (s)   self (s)
  608              0.001408   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  608              0.000629   return a:text

FUNCTION  gitgutter#debug#log()
Called 1 time
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    1              0.000004   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  <SNR>102_exec_separator()
Called 63 times
Total time:   0.030310
 Self time:   0.002395

count  total (s)   self (s)
   63              0.000108   if pumvisible()
                                return
                              endif
   63   0.007756   0.000365   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   63   0.007362   0.000338   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   63              0.000193   let group = a:from.'_to_'.a:to.a:suffix
   63              0.000066   if a:inverse
   18              0.000083     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   18              0.000022   else
   45              0.000193     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   45              0.000031   endif
   63              0.000211   let a:dict[group] = colors
   63   0.013920   0.000420   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>119_RunLinter()
Called 21 times
Total time:   0.274690
 Self time:   0.003168

count  total (s)   self (s)
   21              0.000082     if !empty(a:linter.lsp)
                                    return s:CheckWithLSP(a:buffer, a:linter)
                                else
   21   0.092553   0.000503         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   21   0.000516   0.000167         if ale#engine#IsExecutable(a:buffer, l:executable)
   21   0.181243   0.002120             return s:InvokeChain(a:buffer, a:linter, 0, [])
                                    endif
                                endif
                            
                                return 0

FUNCTION  ale#job#ValidateArguments()
Called 21 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
   21              0.000055     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  <SNR>18_abs_path()
Called 5 times
Total time:   0.000684
 Self time:   0.000684

count  total (s)   self (s)
    5              0.000638   let p = resolve(expand('#'.a:bufnr.':p'))
    5              0.000039   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#path#IsAbsolute()
Called 16 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
   16              0.000064     if has('win32') && a:filename[:0] is# '\'
                                    return 1
                                endif
                            
                                " Check for /foo and C:\foo, etc.
   16              0.000077     return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'

FUNCTION  gitgutter#utility#extension()
Called 1 time
Total time:   0.000145
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000145   0.000017   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  ale#engine#ProcessChain()
Called 21 times
Total time:   0.095922
 Self time:   0.001688

count  total (s)   self (s)
   21              0.000080     let l:output_stream = get(a:linter, 'output_stream', 'stdout')
   21              0.000051     let l:read_buffer = a:linter.read_buffer
   21              0.000036     let l:chain_index = a:chain_index
   21              0.000033     let l:input = a:input
                            
   21              0.000052     if has_key(a:linter, 'command_chain')
                                    while l:chain_index < len(a:linter.command_chain)
                                        " Run a chain of commands, one asynchronous command after the other,
                                        " so that many programs can be run in a sequence.
                                        let l:chain_item = a:linter.command_chain[l:chain_index]
                            
                                        if l:chain_index == 0
                                            " The first callback in the chain takes only a buffer number.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer)
                                        else
                                            " The second callback in the chain takes some input too.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer,   l:input)
                                        endif
                            
                                        if !empty(l:command)
                                            " We hit a command to run, so we'll execute that
                            
                                            " The chain item can override the output_stream option.
                                            if has_key(l:chain_item, 'output_stream')
                                                let l:output_stream = l:chain_item.output_stream
                                            endif
                            
                                            " The chain item can override the read_buffer option.
                                            if has_key(l:chain_item, 'read_buffer')
                                                let l:read_buffer = l:chain_item.read_buffer
                                            elseif l:chain_index != len(a:linter.command_chain) - 1
                                                " Don't read the buffer for commands besides the last one
                                                " in the chain by default.
                                                let l:read_buffer = 0
                                            endif
                            
                                            break
                                        endif
                            
                                        " Command chain items can return an empty string to indicate that
                                        " a command should be skipped, so we should try the next item
                                        " with no input.
                                        let l:input = []
                                        let l:chain_index += 1
                                    endwhile
                                else
   21   0.094484   0.000250         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
   21              0.000014     endif
                            
   21              0.000157     return {   'command': l:command,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': l:output_stream,   'next_chain_index': l:chain_index + 1,   'read_buffer': l:read_buffer,}

FUNCTION  ale#python#FindVirtualenv()
Called 42 times
Total time:   0.157534
 Self time:   0.087961

count  total (s)   self (s)
  378   0.012798   0.002300     for l:path in ale#path#Upwards(expand('#' . a:buffer . ':p:h'))
                                    " Skip empty path components returned in MSYS.
  336              0.000700         if empty(l:path)
                                        continue
                                    endif
                            
 2352   0.013046   0.004713         for l:dirname in ale#Var(a:buffer, 'virtualenv_dir_names')
 2016   0.048264   0.021772             let l:venv_dir = ale#path#Simplify(   join([l:path, l:dirname], s:sep))
 2016   0.049564   0.025314             let l:script_filename = ale#path#Simplify(   join([l:venv_dir, s:bin_dir, 'activate'], s:sep))
                            
 2016              0.018825             if filereadable(l:script_filename)
                                            return l:venv_dir
                                        endif
 2016              0.003416         endfor
  336              0.000321     endfor
                            
   42              0.000164     return $VIRTUAL_ENV

FUNCTION  ale#CallWithCooldown()
Called 86 times
Total time:   0.358699
 Self time:   0.004773

count  total (s)   self (s)
   86   0.001233   0.000572     let l:now = ale#util#ClockMilliseconds()
                            
   86              0.000488     if l:now < get(s:timestamp_map, a:timestamp_key, -1)
                                    return 0
                                endif
                            
   86              0.000443     let s:timestamp_map[a:timestamp_key] = l:now + s:error_delay_ms
                            
   86   0.332291   0.002799     let l:return_value = call(a:func, a:arglist)
                            
   86              0.000256     let s:timestamp_map[a:timestamp_key] = -1
                            
   86              0.000160     return l:return_value

FUNCTION  <SNR>131_InvokeCompletion()
Called 34 times
Total time:   0.042341
 Self time:   0.032044

count  total (s)   self (s)
   34              0.031498   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
   34   0.010693   0.000396   call s:PollCompletion()

FUNCTION  <SNR>131_OnCompleteDone()
Called 14 times
Total time:   0.004183
 Self time:   0.004183

count  total (s)   self (s)
   14              0.004172   exec s:python_command "ycm_state.OnCompleteDone()"

FUNCTION  <SNR>83_ExitInsertMode()
Called 2 times
Total time:   0.000405
 Self time:   0.000405

count  total (s)   self (s)
    2              0.000002 python3 << endOfPython
                            
                            row, col = vim.current.window.cursor
                            
                            if vim.current.line.strip() == "":
                                vim.current.window.cursor = (row, 1)
                                vim.current.line = ""
                            
                            endOfPython

FUNCTION  ale#Queue()
Called 43 times
Total time:   0.048220
 Self time:   0.001048

count  total (s)   self (s)
   43              0.000062     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
                                " Default linting_flag to ''
   43              0.000147     let l:linting_flag = get(a:000, 0, '')
   43              0.000132     let l:buffer = get(a:000, 1, bufnr(''))
                            
   43   0.047689   0.000517     return ale#CallWithCooldown(   'dont_queue_until',   function('s:ALEQueueImpl'),   [a:delay, l:linting_flag, l:buffer],)

FUNCTION  <SNR>119_HandleExit()
Called 41 times
Total time:   0.473831
 Self time:   0.002879

count  total (s)   self (s)
   41              0.000141     if !has_key(s:job_info_map, a:job_id)
   21              0.000016         return
                                endif
                            
   20              0.000070     let l:job_info = s:job_info_map[a:job_id]
   20              0.000045     let l:linter = l:job_info.linter
   20              0.000032     let l:output = l:job_info.output
   20              0.000028     let l:buffer = l:job_info.buffer
   20              0.000045     let l:next_chain_index = l:job_info.next_chain_index
                            
   20              0.000038     if g:ale_history_enabled
   20   0.001364   0.000152         call ale#history#SetExitCode(l:buffer, a:job_id, a:exit_code)
   20              0.000016     endif
                            
                                " Remove this job from the list.
   20   0.001789   0.000115     call ale#job#Stop(a:job_id)
   20              0.000076     call remove(s:job_info_map, a:job_id)
   20              0.000578     call filter(g:ale_buffer_info[l:buffer].job_list, 'v:val isnot# a:job_id')
   20              0.000114     call filter(g:ale_buffer_info[l:buffer].active_linter_list, 'v:val isnot# l:linter.name')
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
   20   0.000436   0.000136     if ale#util#InSandbox()
                                    return
                                endif
                            
   20              0.000112     if has('nvim') && !empty(l:output) && empty(l:output[-1])
                                    call remove(l:output, -1)
                                endif
                            
   20              0.000088     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    call s:InvokeChain(l:buffer, l:linter, l:next_chain_index, l:output)
                                    return
                                endif
                            
                                " Log the output of the command for ALEInfo if we should.
   20              0.000037     if g:ale_history_enabled && g:ale_history_log_output
   20   0.000749   0.000151         call ale#history#RememberOutput(l:buffer, a:job_id, l:output[:])
   20              0.000016     endif
                            
   20   0.028154   0.000290     let l:loclist = ale#util#GetFunction(l:linter.callback)(l:buffer, l:output)
                            
   20   0.439482   0.000178     call ale#engine#HandleLoclist(l:linter.name, l:buffer, l:loclist)

FUNCTION  ale#util#ClockMilliseconds()
Called 86 times
Total time:   0.000661
 Self time:   0.000661

count  total (s)   self (s)
   86              0.000591     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ale#job#PrepareCommand()
Called 21 times
Total time:   0.002468
 Self time:   0.001925

count  total (s)   self (s)
   21   0.000671   0.000128     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
   21              0.000130     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
   21              0.000079     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
   21              0.000737     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
   21              0.000621     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  <SNR>137_CloseWindowIfNeeded()
Called 19 times
Total time:   0.001194
 Self time:   0.000225

count  total (s)   self (s)
   19   0.001145   0.000176     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
   19              0.000019         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_id = s:BufWinId(a:buffer)
                            
                                        if g:ale_set_loclist && empty(getloclist(l:win_id))
                                            lclose
                                        endif
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  <SNR>112_GetDir()
Called 39 times
Total time:   0.038450
 Self time:   0.000571

count  total (s)   self (s)
   39   0.038240   0.000361     let l:project_root = ale#python#FindProjectRoot(a:buffer)
                            
   39              0.000161     return !empty(l:project_root)   ? l:project_root   : expand('#' . a:buffer . ':p:h')

FUNCTION  <SNR>128_write_buffer()
Called 1 time
Total time:   0.002439
 Self time:   0.002439

count  total (s)   self (s)
    1              0.000170   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    1              0.000009   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    1              0.000007   let fenc = getbufvar(a:bufnr, '&fileencoding')
    1              0.000004   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
    1              0.000006   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
    1              0.002219   call writefile(bufcontents, a:file)

FUNCTION  ale#Escape()
Called 103 times
Total time:   0.001304
 Self time:   0.001304

count  total (s)   self (s)
  103              0.000334     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
  103              0.000321     return shellescape (a:str)

FUNCTION  <SNR>119_RemoveProblemsForDisabledLinters()
Called 20 times
Total time:   0.002212
 Self time:   0.002212

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
   20              0.000051     let l:name_map = {}
                            
   60              0.000110     for l:linter in a:linters
   40              0.000147         let l:name_map[l:linter.name] = 1
   40              0.000043     endfor
                            
   20              0.001724     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  <SNR>18_winshell()
Called 2 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    2              0.000033   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>131_InsideCommentOrString()
Called 41 times
Total time:   0.030184
 Self time:   0.030184

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
   41              0.029602   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
   41              0.000216   if stridx(syntax_group, 'Comment') > -1
                                return 1
                              endif
                            
   41              0.000076   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
   41              0.000026   return 0

FUNCTION  <SNR>124_VimExitCallback()
Called 21 times
Total time:   0.456174
 Self time:   0.001652

count  total (s)   self (s)
   21   0.000902   0.000365     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
   21              0.000091     let l:info = get(s:job_map, l:job_id, {})
                            
   21              0.000038     if empty(l:info)
                                    return
                                endif
                            
   21              0.000057     let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
   21              0.000095     if ch_status(job_getchannel(a:job)) is# 'closed'
   20              0.000021         try
   20              0.000073             if !empty(l:info) && has_key(l:info, 'exit_cb')
   20   0.454498   0.000513                 call ale#util#GetFunction(l:info.exit_cb)(l:job_id, a:exit_code)
   20              0.000010             endif
   20              0.000020         finally
                                        " Automatically forget about the job after it's done.
   20              0.000096             if has_key(s:job_map, l:job_id)
   20              0.000067                 call remove(s:job_map, l:job_id)
   20              0.000012             endif
   20              0.000019         endtry
   20              0.000009     endif

FUNCTION  delimitMate#WithinEmptyPair()
Called 8 times
Total time:   0.001262
 Self time:   0.000275

count  total (s)   self (s)
                              " if cursor is at column 1 return 0
    8              0.000027   if col('.') == 1
                                return 0
                              endif
                              " get char before the cursor.
    8   0.000599   0.000074   let char1 = s:get_char(-1)
                              " get char under the cursor.
    8   0.000233   0.000054   let char2 = s:get_char(0)
    8   0.000367   0.000084   return delimitMate#IsEmptyPair( char1.char2 )

FUNCTION  <SNR>108_ALEQueueImpl()
Called 43 times
Total time:   0.045409
 Self time:   0.002876

count  total (s)   self (s)
   43              0.000106     if a:linting_flag isnot# '' && a:linting_flag isnot# 'lint_file'
                                    throw "linting_flag must be either '' or 'lint_file'"
                                endif
                            
   43              0.000117     if type(a:buffer) != type(0)
                                    throw 'buffer_number must be a Number'
                                endif
                            
   43   0.004240   0.000475     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Remember that we want to check files for this buffer.
                                " We will remember this until we finally run the linters, via any event.
   43              0.000068     if a:linting_flag is# 'lint_file'
    1              0.000007         let s:should_lint_file_for_buffer[a:buffer] = 1
    1              0.000000     endif
                            
   43              0.000053     if s:lint_timer != -1
   43              0.000125         call timer_stop(s:lint_timer)
   43              0.000056         let s:lint_timer = -1
   43              0.000025     endif
                            
   43   0.015956   0.000458     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
                            
                                " Don't set up buffer data and so on if there are no linters to run.
   43              0.000076     if empty(l:linters)
                                    " If we have some previous buffer data, then stop any jobs currently
                                    " running and clear everything.
                                    if has_key(g:ale_buffer_info, a:buffer)
                                        call ale#engine#RunLinters(a:buffer, [], 1)
                                    endif
                            
                                    return
                                endif
                            
   43              0.000050     if a:delay > 0
   42              0.000125         let s:queued_buffer_number = a:buffer
   42              0.000194         let s:lint_timer = timer_start(a:delay, function('ale#Lint'))
   42              0.000022     else
    1   0.023278   0.000008         call ale#Lint(-1, a:buffer)
    1              0.000001     endif

FUNCTION  <SNR>131_AllowedToCompleteInCurrentBuffer()
Called 89 times
Total time:   0.005929
 Self time:   0.000649

count  total (s)   self (s)
   89   0.005869   0.000589   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>131_PollFileParseResponse()
Called 2 times
Total time:   0.001681
 Self time:   0.001111

count  total (s)   self (s)
    2   0.000506   0.000022   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    2              0.001034   exec s:python_command "ycm_state.HandleFileParseRequest()"
    2   0.000108   0.000022   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  airline#parts#ffenc()
Called 76 times
Total time:   0.002093
 Self time:   0.002093

count  total (s)   self (s)
   76              0.000367   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   76              0.000155   let bomb     = &l:bomb ? '[BOM]' : ''
   76              0.000616   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   76              0.000321   if expected is# &fenc.bomb.ff
                                return ''
                              else
   76              0.000382     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>119_GatherOutput()
Called 45 times
Total time:   0.000587
 Self time:   0.000587

count  total (s)   self (s)
   45              0.000252     if has_key(s:job_info_map, a:job_id)
   45              0.000257         call add(s:job_info_map[a:job_id].output, a:line)
   45              0.000034     endif

FUNCTION  gitgutter#utility#shellescape()
Called 4 times
Total time:   0.000761
 Self time:   0.000726

count  total (s)   self (s)
    4              0.000564   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    2              0.000008     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    2              0.000012     return shellescape(a:arg)
                              endif

FUNCTION  ale#linter#GetCommand()
Called 21 times
Total time:   0.094234
 Self time:   0.000400

count  total (s)   self (s)
   21   0.094228   0.000394     return has_key(a:linter, 'command_callback')   ? ale#util#GetFunction(a:linter.command_callback)(a:buffer)   : a:linter.command

FUNCTION  airline#util#ignore_buf()
Called 76 times
Total time:   0.006302
 Self time:   0.006302

count  total (s)   self (s)
   76              0.000590   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify')
   76              0.005631   return match(a:name, pat) > -1

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 5 times
Total time:   0.002240
 Self time:   0.000239

count  total (s)   self (s)
    5              0.000024   if getbufvar(a:bufnr, '&modified')
    4              0.000054     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000003   else
    1              0.000019     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    1              0.000001   endif
                            
    5              0.000009   if !empty(colors)
    5   0.002092   0.000091     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    5              0.000003   endif

FUNCTION  <SNR>126_build_command()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000006   if has('unix')
    1              0.000005     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#async#available()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return s:available

FUNCTION  <SNR>18_unc_path()
Called 1 time
Total time:   0.000164
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000162   0.000019   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>110_GetLinterNames()
Called 63 times
Total time:   0.001007
 Self time:   0.001007

count  total (s)   self (s)
   63              0.000295     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
   63              0.000145     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
   63              0.000200     if type(l:buffer_ale_linters) is type([])
   63              0.000091         return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
                                if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
                                if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
                                if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'

FUNCTION  <SNR>83_FormatCurrentLine()
Called 1 time
Total time:   0.004620
 Self time:   0.004620

count  total (s)   self (s)
    1              0.000001 python3 << endOfPython
                            
                            import autopep8
                            import re
                            import astformat
                            
                            line = vim.current.line
                            row, col = vim.current.window.cursor
                            space = ''
                            if len(line) > 79:
                            	toolong = True
                            else:
                            	toolong = False
                            
                                #for char in line:
                                #	if char == ' ' or char == '\t':
                                #		space = space + char
                                #	else:
                                #		break
                            
                            extra = line.lstrip()
                            space = " " * (len(line) - len(extra))
                            
                            if extra == '':
                            	pass
                            else:
                            	oldextralen = len(extra)
                            	if extra == "##" and (row > 1 and (re.match("^\s*def ", vim.current.buffer[row-2]) or re.match("^\s*class ", vim.current.buffer[row-2]))):
                            		vim.current.line = space + '"""'
                            		vim.current.buffer.append("", row)
                            		vim.current.buffer[row] = space + '"""'
                            		vim.current.window.cursor = (row, len(space) + 3)
                            	elif extra != '':
                            		flag = False
                            		if toolong:
                            			extra, flag = astformat.formatif(extra)
                            		if not flag:
                            			extra = autopep8.fix_code(extra)[:-1]
                            		if '\n' in extra:
                            			extras = extra.split('\n')
                            			for i in range(len(extras)-1):
                            				vim.current.buffer.append("", row)
                            			for i, v in enumerate(extras):
                            				vim.current.buffer[row + i - 1] = space + v
                            			vim.current.window.cursor = (row + len(extras) - 1, len(space) + len(extras[-1]))
                            		else:
                            			expandlen = len(extra) - oldextralen
                            			vim.current.line = space + extra
                            			vim.current.window.cursor = (row, col + expandlen)
                            
                            endOfPython

FUNCTION  <SNR>131_PollCompletion()
Called 79 times
Total time:   0.026330
 Self time:   0.002716

count  total (s)   self (s)
   79   0.014841   0.000955   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
   58              0.000817     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
   58              0.000067     return
                              endif
                            
   21   0.009187   0.000177   let response = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
   21              0.000188   let s:completion = {   'start_column': response.completion_start_column,   'candidates': response.completions }
   21   0.000848   0.000130   call s:Complete()

FUNCTION  <SNR>136_BuildSignMap()
Called 20 times
Total time:   0.036896
 Self time:   0.019976

count  total (s)   self (s)
   20   0.000566   0.000113     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
   20              0.000027     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is type(0) && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
   20              0.000044         let l:selected_grouped_items = a:grouped_items
   20              0.000008     endif
                            
   20              0.000050     let l:sign_map = {}
   20              0.000041     let l:sign_offset = g:ale_sign_offset
                            
  376              0.000545     for [l:line, l:sign_id, l:name] in a:current_sign_list
  356              0.002424         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
  356              0.000482         if l:sign_id > l:sign_offset
  324              0.000447             let l:sign_offset = l:sign_id
  324              0.000198         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
  356              0.000786         call add(l:sign_info.current_id_list, l:sign_id)
  356              0.000792         call add(l:sign_info.current_name_list, l:name)
                            
  356              0.000865         let l:sign_map[l:line] = l:sign_info
  356              0.000484     endfor
                            
  376              0.000361     for l:group in l:selected_grouped_items
  356              0.000560         let l:line = l:group[0].lnum
  356              0.002372         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
  356   0.018174   0.001707         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
  356              0.000580         let l:sign_info.items = l:group
                            
  356              0.000958         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
  356              0.000370         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
  353              0.000819             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
  353              0.000204         else
                                        " This sign name replaces the previous name, so use a new ID.
    3              0.000006             let l:sign_info.new_id = l:sign_offset + 1
    3              0.000004             let l:sign_offset += 1
    3              0.000003         endif
                            
  356              0.000758         let l:sign_map[l:line] = l:sign_info
  356              0.000396     endfor
                            
   20              0.000022     return l:sign_map

FUNCTION  <SNR>124_VimOutputCallback()
Called 45 times
Total time:   0.006740
 Self time:   0.002903

count  total (s)   self (s)
   45              0.000497     let l:job = ch_getjob(a:channel)
   45   0.003335   0.000814     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
   45              0.000350     if l:job_id > 0 && has_key(s:job_map, l:job_id)
   45   0.002344   0.001028         call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
   45              0.000041     endif

FUNCTION  airline#parts#paste()
Called 76 times
Total time:   0.000266
 Self time:   0.000266

count  total (s)   self (s)
   76              0.000195   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>102_Get()
Called 756 times
Total time:   0.004343
 Self time:   0.004343

count  total (s)   self (s)
  756              0.001705   let res=get(a:dict, a:key, '')
  756              0.000891   if res is ''
  394              0.000293     return ''
                              else
  362              0.000543     return a:prefix. res
                              endif

FUNCTION  ale#util#BinarySearch()
Called 3 times
Total time:   0.000539
 Self time:   0.000539

count  total (s)   self (s)
    3              0.000010     let l:min = 0
    3              0.000011     let l:max = len(a:loclist) - 1
                            
    9              0.000008     while 1
    9              0.000012         if l:max < l:min
                                        return -1
                                    endif
                            
    9              0.000020         let l:mid = (l:min + l:max) / 2
    9              0.000022         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
    9              0.000017         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
    6              0.000008             let l:min = l:mid + 1
    6              0.000006         elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
    3              0.000005             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    3              0.000029             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
    3              0.000026             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    3              0.000010             let l:item_column = a:loclist[l:index].col
                            
    3              0.000013             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
    3              0.000004             return l:index
                                    endif
    6              0.000006     endwhile

FUNCTION  ale#events#SaveEvent()
Called 1 time
Total time:   0.023930
 Self time:   0.000071

count  total (s)   self (s)
    1   0.000033   0.000007     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    1              0.000001     if l:should_lint
    1              0.000004         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    1              0.000001     endif
                            
    1   0.000021   0.000004     if ale#Var(a:buffer, 'fix_on_save')
                                    let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
                                endif
                            
    1   0.000045   0.000038     if l:should_lint && !ale#events#QuitRecently(a:buffer)
    1   0.023816   0.000007         call ale#Queue(0, 'lint_file', a:buffer)
    1              0.000001     endif

FUNCTION  airline#parts#readonly()
Called 76 times
Total time:   0.008109
 Self time:   0.001807

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files, 
                              " but not special ones like e.g. NERDTree)
   76   0.007229   0.000927   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
   76              0.000224   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   76              0.000130     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  ale#sign#ParseSigns()
Called 20 times
Total time:   0.061705
 Self time:   0.061705

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
   20              0.000039     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
   20              0.000023     let l:result = []
   20              0.000035     let l:is_dummy_sign_set = 0
                            
  436              0.000460     for l:line in a:line_list
  416              0.054316         let l:match = matchlist(l:line, l:pattern)
                            
  416              0.000818         if len(l:match) > 0
  376              0.000809             if l:match[3] is# 'ALEDummySign'
   20              0.000039                 let l:is_dummy_sign_set = 1
   20              0.000015             else
  356              0.001988                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
  356              0.000210             endif
  376              0.000189         endif
  416              0.001125     endfor
                            
   20              0.000049     return [l:is_dummy_sign_set, l:result]

FUNCTION  <SNR>97_check_mixed_indent_file()
Called 1 time
Total time:   0.000494
 Self time:   0.000494

count  total (s)   self (s)
    1              0.000011   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000007   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    1              0.000002     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000342   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000113   let indent_spc  = search(head_spc, 'nw')
    1              0.000003   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    1              0.000001     return ''
                              endif

FUNCTION  ale#util#GetItemPriority()
Called 672 times
Total time:   0.007517
 Self time:   0.007517

count  total (s)   self (s)
  672              0.001027     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
  672              0.000770     if a:item.type is# 'W'
  656              0.001610         if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
  656              0.000748         return g:ale#util#warning_priority
                                endif
                            
   16              0.000040     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
   16              0.000021     return g:ale#util#error_priority

FUNCTION  ale#path#BufferCdString()
Called 1 time
Total time:   0.000080
 Self time:   0.000051

count  total (s)   self (s)
    1   0.000080   0.000051     return ale#path#CdString(fnamemodify(bufname(a:buffer), ':p:h'))

FUNCTION  ale#cursor#TruncatedEcho()
Called 3 times
Total time:   0.002299
 Self time:   0.002286

count  total (s)   self (s)
    3              0.000013     let l:message = a:original_message
                                " Change tabs to spaces.
    3              0.000018     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    3              0.000012     let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    3              0.000008     let l:shortmess_options = &l:shortmess
                            
    3              0.000003     try
    3              0.000012         let l:cursor_position = getcurpos()
                            
                                    " The message is truncated and saved to the history.
    3   0.000041   0.000033         setlocal shortmess+=T
    3              0.002106         exec "norm! :echomsg l:message\n"
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    3              0.000019         if l:cursor_position != getcurpos()
                                        call setpos('.', l:cursor_position)
                                    endif
    3              0.000004     finally
    3   0.000025   0.000020         let &l:shortmess = l:shortmess_options
    3              0.000003     endtry

FUNCTION  ale#engine#RunLinters()
Called 20 times
Total time:   0.285075
 Self time:   0.006007

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
   20   0.000617   0.000282     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
   20   0.001671   0.000248     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
   20   0.002546   0.000334     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
   20   0.000517   0.000295     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
   20   0.001391   0.001205     silent doautocmd <nomodeline> User ALELintPre
                            
   60              0.000697     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   40              0.000104         if !l:linter.lint_file || a:should_lint_file
   21   0.275556   0.000866             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
   21              0.000084                 let l:can_clear_results = 0
   21              0.000090             endif
   21              0.000022         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
   19              0.000027             let l:can_clear_results = 0
   19              0.000009         endif
   40              0.000052     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
   20              0.000030     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  airline#highlighter#exec()
Called 440 times
Total time:   0.100612
 Self time:   0.031348

count  total (s)   self (s)
  440              0.000764   if pumvisible()
                                return
                              endif
  440              0.000649   let colors = a:colors
  440              0.000491   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  440   0.053815   0.002621   let old_hi = airline#highlighter#get_highlight(a:group)
  440              0.000874   if len(colors) == 4
   63              0.000161     call add(colors, '')
   63              0.000036   endif
  440              0.000668   if g:airline_gui_mode ==# 'gui'
  440              0.001870     let new_hi = [colors[0], colors[1], '', '', colors[4]]
  440              0.000300   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
  440   0.012388   0.002202   let colors = s:CheckDefined(colors)
  440   0.005728   0.002187   if old_hi != new_hi || !s:hl_group_exists(a:group)
  108   0.007460   0.003117     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
  108              0.002130     exe cmd
  108              0.000333     if has_key(s:hl_groups, a:group)
  108              0.000246       let s:hl_groups[a:group] = colors
  108              0.000082     endif
  108              0.000054   endif

FUNCTION  gitgutter#utility#setbufvar()
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000019   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
    2              0.000007   let needs_setting = empty(dict)
    2              0.000011   let dict[a:varname] = a:val
    2              0.000003   if needs_setting
                                call setbufvar(+a:buffer, 'gitgutter', dict)
                              endif

FUNCTION  <SNR>18_exists_file()
Called 1 time
Total time:   0.000303
 Self time:   0.000133

count  total (s)   self (s)
    1   0.000302   0.000132   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>108_ALELintImpl()
Called 20 times
Total time:   0.302321
 Self time:   0.002313

count  total (s)   self (s)
   20   0.003527   0.000171     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
                                " Use the filetype from the buffer
   20   0.011932   0.000355     let l:linters = ale#linter#Get(getbufvar(a:buffer, '&filetype'))
   20              0.000050     let l:should_lint_file = 0
                            
                                " Check if we previously requested checking the file.
   20              0.000180     if has_key(s:should_lint_file_for_buffer, a:buffer)
    1              0.000003         unlet s:should_lint_file_for_buffer[a:buffer]
                                    " Lint files if they exist.
    1              0.000044         let l:should_lint_file = filereadable(expand('#' . a:buffer . ':p'))
    1              0.000001     endif
                            
   20   0.286048   0.000973     call ale#engine#RunLinters(a:buffer, l:linters, l:should_lint_file)

FUNCTION  <SNR>131_OnCursorMovedNormalMode()
Called 2 times
Total time:   0.000667
 Self time:   0.000526

count  total (s)   self (s)
    2   0.000153   0.000012   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    2              0.000507   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  airline#extensions#whitespace#check()
Called 76 times
Total time:   0.064324
 Self time:   0.029101

count  total (s)   self (s)
   76              0.000265   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   76              0.000446   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
   76              0.000449   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   76              0.000237   if !exists('b:airline_whitespace_check')
    1              0.000008     let b:airline_whitespace_check = ''
    1              0.000007     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000001     let trailing = 0
    1              0.000002     let check = 'trailing'
    1              0.000010     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000001       try
    1              0.000005         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.021207         let trailing = search(regexp, 'nw')
    1              0.000004       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    1              0.000001     endif
                            
    1              0.000002     let mixed = 0
    1              0.000002     let check = 'indent'
    1              0.000011     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.033725   0.000066       let mixed = s:check_mixed_indent()
    1              0.000003     endif
                            
    1              0.000003     let mixed_file = ''
    1              0.000001     let check = 'mixed-indent-file'
    1              0.000013     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000568   0.000074       let mixed_file = s:check_mixed_indent_file()
    1              0.000001     endif
                            
    1              0.000002     let long = 0
    1              0.000004     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000005     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
    1              0.000001   endif
   76   0.001453   0.000383   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  ale#path#CdString()
Called 21 times
Total time:   0.000474
 Self time:   0.000135

count  total (s)   self (s)
   21   0.000465   0.000126     return 'cd ' . ale#Escape(a:directory) . ' && '

FUNCTION  ale#python#FindExecutable()
Called 42 times
Total time:   0.161744
 Self time:   0.001893

count  total (s)   self (s)
   42   0.001762   0.000427     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
   42   0.157955   0.000421     let l:virtualenv = ale#python#FindVirtualenv(a:buffer)
                            
   42              0.000091     if !empty(l:virtualenv)
                                    for l:path in a:path_list
                                        let l:ve_executable = ale#path#Simplify(   join([l:virtualenv, s:bin_dir, l:path], s:sep))
                            
                                        if executable(l:ve_executable)
                                            return l:ve_executable
                                        endif
                                    endfor
                                endif
                            
   42   0.001232   0.000250     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  ale#util#StartPartialTimer()
Called 18 times
Total time:   0.000273
 Self time:   0.000273

count  total (s)   self (s)
   18              0.000137     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
   18              0.000086     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
   18              0.000023     return l:timer_id

FUNCTION  <SNR>135_CreateCountDict()
Called 20 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
   20              0.000109     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  <SNR>131_IdentifierFinishedOperations()
Called 41 times
Total time:   0.018163
 Self time:   0.009933

count  total (s)   self (s)
   41   0.008483   0.000253   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
   29              0.000043     return
                              endif
   12              0.009505   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
   12              0.000049   let s:force_semantic = 0
   12              0.000030   let s:completion = s:default_completion

FUNCTION  <SNR>131_OnBlankLine()
Called 41 times
Total time:   0.010948
 Self time:   0.000277

count  total (s)   self (s)
   41   0.010887   0.000216   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  gitgutter#utility#repo_path()
Called 3 times
Total time:   0.000361
 Self time:   0.000126

count  total (s)   self (s)
    3   0.000179   0.000097   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
    3   0.000177   0.000024   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#history#SetExitCode()
Called 20 times
Total time:   0.001212
 Self time:   0.000446

count  total (s)   self (s)
   20   0.000991   0.000225     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
   20              0.000086     let l:obj.exit_code = a:exit_code
   20              0.000038     let l:obj.status = 'finished'

FUNCTION  ale#highlight#CreatePositions()
Called 456 times
Total time:   0.002141
 Self time:   0.002141

count  total (s)   self (s)
  456              0.000538     if a:line >= a:end_line
                                    " For single lines, just return the one position.
  456              0.001267         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  <SNR>126_on_stderr_vim()
Called 1 time
Total time:   0.000265
 Self time:   0.000082

count  total (s)   self (s)
    1   0.000237   0.000054   call self.handler.err(self.buffer)
    1              0.000002   try
    1              0.000021     call ch_close(a:channel)  " so close_cb and its 'out' handler are not triggered
    1              0.000002   catch /E906/
                                " noop
                              endtry

FUNCTION  ale_linters#python#pylint#GetExecutable()
Called 2 times
Total time:   0.007657
 Self time:   0.000015

count  total (s)   self (s)
    2   0.007657   0.000015     return ale#python#FindExecutable(a:buffer, 'python_pylint', ['pylint'])

FUNCTION  <SNR>98_wordcount_update()
Called 43 times
Total time:   0.003388
 Self time:   0.003388

count  total (s)   self (s)
   43              0.000179   if empty(bufname(''))
                                return
                              endif
   43              0.002045   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  <SNR>119_InvokeChain()
Called 21 times
Total time:   0.179123
 Self time:   0.003164

count  total (s)   self (s)
   21   0.096195   0.000273     let l:options = ale#engine#ProcessChain(a:buffer, a:linter, a:chain_index, a:input)
                            
   21   0.082834   0.002797     return s:RunJob(l:options)

FUNCTION  <SNR>102_get_array()
Called 566 times
Total time:   0.005190
 Self time:   0.005190

count  total (s)   self (s)
  566              0.002467   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  566              0.002405   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  gitgutter#utility#windows()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000020   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
Called 76 times
Total time:   0.002393
 Self time:   0.002393

count  total (s)   self (s)
   76              0.001282   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   76              0.000150   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
   76              0.000065   return ''

FUNCTION  ale#Lint()
Called 20 times
Total time:   0.306670
 Self time:   0.001491

count  total (s)   self (s)
   20              0.000183     if a:0 > 1
                                    " Use the buffer number given as the optional second argument.
    1              0.000001         let l:buffer = a:2
    1              0.000002     elseif a:0 > 0 && a:1 == s:lint_timer
                                    " Use the buffer number for the buffer linting was queued for.
   19              0.000089         let l:buffer = s:queued_buffer_number
   19              0.000028     else
                                    " Use the current buffer number.
                                    let l:buffer = bufnr('')
                                endif
                            
   20   0.305935   0.000756     return ale#CallWithCooldown(   'dont_lint_until',   function('s:ALELintImpl'),   [l:buffer],)

FUNCTION  gitgutter#hunk#summary()
Called 76 times
Total time:   0.001902
 Self time:   0.000827

count  total (s)   self (s)
   76   0.001810   0.000735   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#linter#GetAll()
Called 63 times
Total time:   0.002750
 Self time:   0.002750

count  total (s)   self (s)
   63              0.000135     let l:combined_linters = []
                            
  126              0.000215     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
   63              0.000228         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
   63              0.000580         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   63              0.000090     endfor
                            
   63              0.000093     return l:combined_linters

FUNCTION  <SNR>96_airline_ale_get_line_number()
Called 152 times
Total time:   0.010964
 Self time:   0.009880

count  total (s)   self (s)
  152              0.000182   if a:cnt == 0
   15              0.000013     return ''
                              endif
                            
  137              0.000294   let buffer       = bufnr('')
  137              0.000336   let problem_type = (a:type ==# 'error') ? 'E' : 'W'
  137   0.002512   0.001428   let problems     = copy(ale#engine#GetLoclist(buffer))
                            
  137              0.005056   call filter(problems, 'v:val.bufnr is buffer && v:val.type is# problem_type')
                            
  137              0.000221   if empty(problems)
                                return ''
                              endif
                            
  137              0.000513   let open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
  137              0.000454   let close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
  137              0.000502   return open_lnum_symbol . problems[0].lnum . close_lnum_symbol

FUNCTION  ale#engine#RemoveManagedFiles()
Called 19 times
Total time:   0.007533
 Self time:   0.007347

count  total (s)   self (s)
   19              0.000074     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
   19   0.000273   0.000087     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
   19              0.000044     if has_key(l:info, 'temporary_file_list')
   19              0.000035         for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
   19              0.000042         let l:info.temporary_file_list = []
   19              0.000013     endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
   19              0.000038     if has_key(l:info, 'temporary_directory_list')
   39              0.000071         for l:directory in l:info.temporary_directory_list
   20              0.006574             call delete(l:directory, 'rf')
   20              0.000039         endfor
                            
   19              0.000059         let l:info.temporary_directory_list = []
   19              0.000010     endif

FUNCTION  <SNR>131_OnInsertChar()
Called 43 times
Total time:   0.005114
 Self time:   0.001146

count  total (s)   self (s)
   43   0.004058   0.000397   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   43              0.000218   call timer_stop( s:pollers.completion.id )
   43   0.000665   0.000358   call s:CloseCompletionMenu()

FUNCTION  ale#util#Writefile()
Called 20 times
Total time:   0.020208
 Self time:   0.020208

count  total (s)   self (s)
   20              0.000141     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'v:val . "\r"')   : a:lines
                            
   20              0.020037     call writefile(l:corrected_lines, a:filename) " no-custom-checks

FUNCTION  ale#list#SetLists()
Called 20 times
Total time:   0.005751
 Self time:   0.000566

count  total (s)   self (s)
   20              0.000127     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
    2   0.004942   0.000030         call s:SetListsImpl(-1, a:buffer, a:loclist)
    2              0.000002     else
   18   0.000542   0.000269         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
   18              0.000013     endif

FUNCTION  ale#util#InSandbox()
Called 125 times
Total time:   0.001740
 Self time:   0.001740

count  total (s)   self (s)
  125              0.000141     try
  125              0.000347         function! s:SandboxCheck() abort
                                    endfunction
  125              0.000367     catch /^Vim\%((\a\+)\)\=:E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
  125              0.000120     return 0

FUNCTION  airline#parts#crypt()
Called 76 times
Total time:   0.000495
 Self time:   0.000495

count  total (s)   self (s)
   76              0.000415   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  ale#path#Simplify()
Called 4184 times
Total time:   0.054241
 Self time:   0.054241

count  total (s)   self (s)
 4184              0.008157     if has('unix')
 4184              0.043674         return substitute(simplify(a:path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  airline#extensions#keymap#status()
Called 76 times
Total time:   0.001009
 Self time:   0.001009

count  total (s)   self (s)
   76              0.000494   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   76              0.000437     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  ale#path#Upwards()
Called 120 times
Total time:   0.026641
 Self time:   0.023750

count  total (s)   self (s)
  120              0.000740     let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
  120              0.000536     let l:sep = has('win32') ? '\' : '/'
  120   0.007729   0.004838     let l:parts = split(ale#path#Simplify(a:path), l:pattern)
  120              0.000239     let l:path_list = []
                            
  960              0.001635     while !empty(l:parts)
  840              0.007914         call add(l:path_list, join(l:parts, l:sep))
  840              0.002864         let l:parts = l:parts[:-2]
  840              0.000882     endwhile
                            
  120              0.000464     if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
                                elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
  120              0.001287         call map(l:path_list, '''/'' . v:val')
  120              0.000266         call add(l:path_list, '/')
  120              0.000083     endif
                            
  120              0.000154     return l:path_list

FUNCTION  <SNR>123_TemporaryFilename()
Called 20 times
Total time:   0.000392
 Self time:   0.000392

count  total (s)   self (s)
   20              0.000081     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
   20              0.000036     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
   20              0.000128     return tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  ale#util#GetLineCount()
Called 20 times
Total time:   0.002664
 Self time:   0.002664

count  total (s)   self (s)
   20              0.002647     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  gitgutter#diff#run_diff()
Called 1 time
Total time:   0.007339
 Self time:   0.001266

count  total (s)   self (s)
    1   0.000262   0.000134   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                sleep 5m
                              endwhile
                            
    1   0.000052   0.000011   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    1              0.000003   let cmd = '('
                            
                              " Append buffer number to avoid race conditions between writing and reading
                              " the files when asynchronously processing multiple buffers.
                              "
                              " Without the buffer number, index_file would have a race in the shell
                              " between the second process writing it (with git-show) and the first
                              " reading it (with git-diff).
    1              0.000009   let index_file = s:temp_index.'.'.a:bufnr
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    1              0.000006   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
    1   0.000247   0.000102   let extension = gitgutter#utility#extension(a:bufnr)
    1              0.000006   if !empty(extension)
    1              0.000007     let index_file .= '.'.extension
    1              0.000005     let buff_file .= '.'.extension
    1              0.000002   endif
                            
                              " Write file from index to temporary file.
    1   0.000207   0.000015   let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    1              0.000014   let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.index_file.' && '
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    1   0.002678   0.000239   call s:write_buffer(a:bufnr, buff_file)
                            
                              " Call git-diff with the temporary files.
    1              0.000016   let cmd .= g:gitgutter_git_executable.' --no-pager'
    1              0.000004   if s:c_flag
    1              0.000005     let cmd .= ' -c "diff.autorefreshindex=0"'
    1              0.000004     let cmd .= ' -c "diff.noprefix=false"'
    1              0.000004     let cmd .= ' -c "core.safecrlf=false"'
    1              0.000001   endif
    1              0.000013   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.index_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    1              0.000009   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    1   0.000094   0.000021     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    1              0.000002   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    1              0.000004   let cmd .= ' || exit 0'
                            
    1              0.000003   let cmd .= ')'
                            
    1   0.000985   0.000109   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    1   0.000138   0.000133   if g:gitgutter_async && gitgutter#async#available()
    1   0.002423   0.000249     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    1              0.000030     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  ale#engine#FixLocList()
Called 20 times
Total time:   0.009824
 Self time:   0.006306

count  total (s)   self (s)
   20              0.000031     let l:bufnr_map = {}
   20              0.000067     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
   20   0.002820   0.000156     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
   58              0.000083     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
   38              0.000583         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
   38              0.000081         if has_key(l:old_item, 'code')
   22              0.000035             let l:item.code = l:old_item.code
   22              0.000012         endif
                            
   38   0.000602   0.000200         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
   16              0.000034             let l:filename = l:old_item.filename
   16              0.000034             let l:item.filename = l:filename
                            
   16              0.000033             if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
   16              0.000252                 let l:item.bufnr = bufnr(l:filename)
   16              0.000053                 let l:bufnr_map[l:filename] = l:item.bufnr
   16              0.000014             endif
   16              0.000028         elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
   38              0.000069         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
   38              0.000065         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
   38              0.000068         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
   38              0.000059         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
   38              0.000046         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
   38              0.000094         call add(l:new_loclist, l:item)
   38              0.000059     endfor
                            
   20   0.000603   0.000151     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
   20              0.000040     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
   20              0.000022     return l:new_loclist

FUNCTION  GitGutterGetHunkSummary()
Called 76 times
Total time:   0.002537
 Self time:   0.000635

count  total (s)   self (s)
   76   0.002455   0.000553   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
Called 76 times
Total time:   0.002378
 Self time:   0.000878

count  total (s)   self (s)
   76   0.002329   0.000829   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>119_StopCurrentJobs()
Called 20 times
Total time:   0.001423
 Self time:   0.001357

count  total (s)   self (s)
   20              0.000135     let l:info = get(g:ale_buffer_info, a:buffer, {})
   20              0.000050     let l:new_job_list = []
   20              0.000049     let l:new_active_linter_list = []
                            
   21              0.000179     for l:job_id in get(l:info, 'job_list', [])
    1              0.000004         let l:job_info = get(s:job_info_map, l:job_id, {})
                            
    1              0.000002         if !empty(l:job_info)
    1              0.000002             if a:include_lint_file_jobs || !l:job_info.linter.lint_file
    1   0.000070   0.000004                 call ale#job#Stop(l:job_id)
    1              0.000003                 call remove(s:job_info_map, l:job_id)
    1              0.000001             else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
    1              0.000000         endif
    1              0.000001     endfor
                            
                                " Remove duplicates from the active linter list.
   20              0.000108     call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
   20              0.000076     let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
   20              0.000067     let l:info.active_linter_list = l:new_active_linter_list

FUNCTION  <SNR>132_EchoImpl()
Called 23 times
Total time:   0.005495
 Self time:   0.000630

count  total (s)   self (s)
   23              0.000029     if !g:ale_echo_cursor
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   23              0.000055     if mode() isnot# 'n'
   20              0.000014         return
                                endif
                            
    3   0.000363   0.000025     if ale#ShouldDoNothing(bufnr(''))
                                    return
                                endif
                            
    3              0.000009     let l:buffer = bufnr('')
    3   0.000750   0.000064     let [l:info, l:loc] = s:FindItemAtCursor()
                            
    3              0.000088     if !empty(l:loc)
    3   0.001317   0.000065         let l:format = ale#Var(l:buffer, 'echo_msg_format')
    3   0.000314   0.000024         let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    3   0.002363   0.000064         call ale#cursor#TruncatedEcho(l:msg)
    3              0.000087         let l:info.echoed = 1
    3              0.000008     elseif get(l:info, 'echoed')
                                    " We'll only clear the echoed message when moving off errors once,
                                    " so we don't continually clear the echo line.
                                    execute 'echo'
                                    let l:info.echoed = 0
                                endif

FUNCTION  ale#highlight#SetHighlights()
Called 20 times
Total time:   0.028623
 Self time:   0.001286

count  total (s)   self (s)
   20              0.000599     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
   20              0.000413     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
   20   0.027549   0.000212     call ale#highlight#UpdateHighlights()

FUNCTION  ale#engine#SetResults()
Called 20 times
Total time:   0.405786
 Self time:   0.003689

count  total (s)   self (s)
   20   0.000336   0.000142     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
   20              0.000030     if g:ale_set_signs
   20   0.352250   0.001086         call ale#sign#SetSigns(a:buffer, a:loclist)
   20              0.000014     endif
                            
   20              0.000041     if g:ale_set_quickfix || g:ale_set_loclist
   20   0.005902   0.000151         call ale#list#SetLists(a:buffer, a:loclist)
   20              0.000013     endif
                            
   20              0.000060     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
   20   0.007696   0.000187         call ale#statusline#Update(a:buffer, a:loclist)
   20              0.000015     endif
                            
   20              0.000031     if g:ale_set_highlights
   20   0.028811   0.000188         call ale#highlight#SetHighlights(a:buffer, a:loclist)
   20              0.000012     endif
                            
   20              0.000023     if l:linting_is_done
   19              0.000019         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
   19   0.001090   0.000148             call ale#cursor#EchoCursorWarning()
   19              0.000012         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
   19              0.000075         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
   19              0.000088         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
   19   0.007660   0.000127         call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
   19   0.000934   0.000622         silent doautocmd <nomodeline> User ALELintPost
                                    " remove in 2.0
                                    " Old DEPRECATED name; call it for backwards compatibility.
   19   0.000410   0.000341         silent doautocmd <nomodeline> User ALELint
   19              0.000018     endif

FUNCTION  <SNR>18_not_git_dir()
Called 1 time
Total time:   0.000791
 Self time:   0.000260

count  total (s)   self (s)
    1   0.000790   0.000259   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  ale#path#GetAbsPath()
Called 16 times
Total time:   0.000909
 Self time:   0.000357

count  total (s)   self (s)
   16   0.000311   0.000123     if ale#path#IsAbsolute(a:filename)
                                    return ale#path#Simplify(a:filename)
                                endif
                            
   16              0.000059     let l:sep = has('win32') ? '\' : '/'
                            
   16   0.000464   0.000100     return ale#path#Simplify(a:base_directory . l:sep . a:filename)

FUNCTION  ale#util#GetMatches()
Called 20 times
Total time:   0.006442
 Self time:   0.006442

count  total (s)   self (s)
   20              0.000029     let l:matches = []
   20              0.000081     let l:lines = type(a:lines) == type([]) ? a:lines : [a:lines]
   20              0.000079     let l:patterns = type(a:patterns) == type([]) ? a:patterns : [a:patterns]
                            
   65              0.000086     for l:line in l:lines
   52              0.000073         for l:pattern in l:patterns
   45              0.005310             let l:match = matchlist(l:line, l:pattern)
                            
   45              0.000093             if !empty(l:match)
   38              0.000093                 call add(l:matches, l:match)
   38              0.000034                 break
                                        endif
    7              0.000038         endfor
   45              0.000106     endfor
                            
   20              0.000021     return l:matches

FUNCTION  <SNR>96_ale_refresh()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif

FUNCTION  ale#engine#HandleLoclist()
Called 20 times
Total time:   0.439304
 Self time:   0.003390

count  total (s)   self (s)
   20              0.000078     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   20              0.000031     if empty(l:info)
                                    return
                                endif
                            
                                " Remove this linter from the list of active linters.
                                " This may have already been done when the job exits.
   20              0.000101     call filter(l:info.active_linter_list, 'v:val isnot# a:linter_name')
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
   20   0.010018   0.000194     let l:linter_loclist = ale#engine#FixLocList(a:buffer, a:linter_name, a:loclist)
                            
                                " Remove previous items for this linter.
   20              0.000745     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
   20              0.000047     if !empty(l:linter_loclist)
                                    " Add the new items.
   17              0.000044         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
   17   0.020214   0.001645         call sort(l:info.loclist, 'ale#util#LocItemCompare')
   17              0.000010     endif
                            
   20   0.001813   0.000078     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
   20   0.405981   0.000195     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  gitgutter#hunk#reset()
Called 1 time
Total time:   0.000183
 Self time:   0.000123

count  total (s)   self (s)
    1   0.000106   0.000074   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
    1   0.000076   0.000048   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>94_get_hunks()
Called 76 times
Total time:   0.006491
 Self time:   0.002242

count  total (s)   self (s)
   76              0.000430   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
   76   0.004863   0.000614   return {b:source_func}()

FUNCTION  ale#history#Get()
Called 40 times
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
   40              0.000431     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  gitgutter#utility#is_active()
Called 1 time
Total time:   0.001376
 Self time:   0.000264

count  total (s)   self (s)
    1   0.001375   0.000263   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>131_InsideCommentOrStringAndShouldStop()
Called 41 times
Total time:   0.030805
 Self time:   0.000621

count  total (s)   self (s)
   41   0.030427   0.000243   let retval = s:InsideCommentOrString()
   41              0.000068   let inside_comment = retval == 1
   41              0.000052   let inside_string = retval == 2
                            
   41              0.000093   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
   41              0.000036   return retval

FUNCTION  <SNR>131_OnTextChangedInsertMode()
Called 41 times
Total time:   0.122143
 Self time:   0.017084

count  total (s)   self (s)
   41   0.002290   0.000318   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   41              0.000048   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
   41   0.018458   0.000295   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
   41              0.000142   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
   41   0.042484   0.000731   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
   34   0.001130   0.000300     call s:Complete()
   34   0.042636   0.000295     call s:InvokeCompletion()
   34              0.000033   endif
                            
   41              0.013911   exec s:python_command "ycm_state.OnCursorMoved()"
                            
   41              0.000149   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  ale#engine#GetLoclist()
Called 137 times
Total time:   0.001084
 Self time:   0.001084

count  total (s)   self (s)
  137              0.000375     if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
  137              0.000311     return g:ale_buffer_info[a:buffer].loclist

FUNCTION  <SNR>83_FormatCurrentLineandIndent()
Called 1 time
Total time:   0.008379
 Self time:   0.003759

count  total (s)   self (s)
    1              0.000001 python3 << endOfPython
                            
                            import time
                            import vim
                            import vimbufferutil
                            
                            line = vim.current.line
                            row, col = vim.current.window.cursor
                            
                            if line.strip() == "":
                                vim.current.line = ""
                                if vim.eval("b:autoformat_lastlength") != "-1":
                                    line = " " * int(vim.eval("b:autoformat_lastlength"))
                                vim.current.buffer.append(line, row)
                                vim.current.window.cursor = (row + 1, len(line))
                            else:
                                vim.command("call s:FormatCurrentLine()")
                            
                                extra = line.strip()
                            
                                if extra == "":
                                    vim.current.line = ""
                                    vim.current.buffer.append(line, row)
                                    vim.current.window.cursor = (row + 1, len(line))
                                else:
                                    indentlevel, finishflag = vimbufferutil.getcurrentindent(vim.current.buffer, row)
                                    if not finishflag:
                                        nextindentlevel = indentlevel + 2
                                    elif vim.current.line[-1] == ":":
                                        nextindentlevel = indentlevel + 1
                                    else:
                                        nextindentlevel = indentlevel
                            
                                    vim.current.buffer.append(" " * (4 * (nextindentlevel)), row)
                                    vim.current.window.cursor = (row + 1, 4 * (nextindentlevel))
                            
                            vim.command("let b:autoformat_lastlength = -1")
                            
                            
                            endOfPython

FUNCTION  youcompleteme#CompleteFunc()
Called 34 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
   34              0.000097   if a:findstart
   17              0.000062     return s:completion.start_column - 1
                              endif
   17              0.000033   return s:completion.candidates

FUNCTION  ale#path#IsTempName()
Called 16 times
Total time:   0.000402
 Self time:   0.000158

count  total (s)   self (s)
   16   0.000396   0.000152     return ale#path#Simplify(a:filename)[:len(s:temp_dir) - 1] is# s:temp_dir

FUNCTION  airline#highlighter#get_highlight()
Called 566 times
Total time:   0.064725
 Self time:   0.027847

count  total (s)   self (s)
  566              0.002098   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
  566   0.020050   0.003050     let fg = s:get_syn(a:group, 'fg')
  566   0.017388   0.002700     let bg = s:get_syn(a:group, 'bg')
  566              0.005894     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  566              0.002525     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  566              0.000774     let opts = a:000
  566              0.000579     if bold
  248              0.000339       let opts = ['bold']
  248              0.000160     endif
  566   0.009087   0.003897     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  566              0.000373   endif
  566              0.002007   let s:hl_groups[a:group] = res
  566              0.000517   return res

FUNCTION  ale#history#Add()
Called 21 times
Total time:   0.007436
 Self time:   0.007436

count  total (s)   self (s)
   21              0.000255     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
   21              0.000430     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   21              0.000081     if len(l:history) >= g:ale_max_buffer_history_size
   21              0.001635         let l:history = l:history[1:]
   21              0.000022     endif
                            
   21              0.000216     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   21              0.004219     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>16_get()
Called 79 times
Total time:   0.001633
 Self time:   0.001633

count  total (s)   self (s)
   79              0.000114   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
                              elseif a:0 == 1
                                let bufoptions = get(s:options, bufnr('%'), {})
                                return deepcopy(get(bufoptions, a:name, a:1))
                              else
   79              0.000674     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  <SNR>131_OnFileReadyToParse()
Called 3 times
Total time:   0.003350
 Self time:   0.003078

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    3              0.000007   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    3   0.000287   0.000015   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    2              0.002980     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    2              0.000017     call timer_stop( s:pollers.file_parse_response.id )
    2              0.000032     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    2              0.000003   endif

FUNCTION  ale#linter#GetExecutable()
Called 21 times
Total time:   0.092050
 Self time:   0.000889

count  total (s)   self (s)
   21   0.092033   0.000872     return has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable

FUNCTION  ale_linters#python#mypy#GetCommand()
Called 20 times
Total time:   0.090036
 Self time:   0.000922

count  total (s)   self (s)
   20   0.020343   0.000226     let l:dir = s:GetDir(a:buffer)
   20   0.068075   0.000125     let l:executable = ale_linters#python#mypy#GetExecutable(a:buffer)
                            
   20              0.000169     let l:exec_args = l:executable =~? 'pipenv$'   ? ' run mypy'   : ''
                            
                                " We have to always switch to an explicit directory for a command so
                                " we can know with certainty the base path for the 'filename' keys below.
   20   0.001401   0.000354     return ale#path#CdString(l:dir)   . ale#Escape(l:executable) . l:exec_args   . ' --show-column-numbers '   . ale#Var(a:buffer, 'python_mypy_options')   . ' --shadow-file %s %t %s'

FUNCTION  ale#util#GetFunction()
Called 148 times
Total time:   0.001673
 Self time:   0.001673

count  total (s)   self (s)
  148              0.000749     if type(a:string_or_ref) == type('')
   62              0.000188         return function(a:string_or_ref)
                                endif
                            
   86              0.000145     return a:string_or_ref

FUNCTION  ale#sign#ReadSigns()
Called 20 times
Total time:   0.000862
 Self time:   0.000862

count  total (s)   self (s)
   20              0.000069     redir => l:output
   20              0.000429        silent execute 'sign place buffer=' . a:buffer
   20              0.000068     redir end
                            
   20              0.000269     return split(l:output, "\n")

FUNCTION  <SNR>50_on_window_changed()
Called 14 times
Total time:   0.000668
 Self time:   0.000668

count  total (s)   self (s)
   14              0.000074   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   14              0.000215   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
   14              0.000270   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
   14              0.000015     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  airline#extensions#hunks#get_hunks()
Called 76 times
Total time:   0.013458
 Self time:   0.006967

count  total (s)   self (s)
   76              0.000295   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
   76              0.001123   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
   76   0.006969   0.000478   let hunks = s:get_hunks()
   76              0.000094   let string = ''
   76              0.000136   if !empty(hunks)
  304              0.000448     for i in [0, 1, 2]
  228              0.000649       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
  228              0.001365         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  228              0.000153       endif
  228              0.000443     endfor
   76              0.000055   endif
   76              0.000168   let b:airline_hunks = string
   76              0.000166   let b:airline_changenr = b:changedtick
   76              0.000168   let s:airline_winwidth = winwidth(0)
   76              0.000085   return string

FUNCTION  delimitMate#BS()
Called 8 times
Total time:   0.013745
 Self time:   0.000980

count  total (s)   self (s)
    8   0.009174   0.000249   if s:is_forbidden("")
                                let extra = ''
                              elseif &bs !~ 'start\|2'
                                let extra = ''
                              elseif delimitMate#WithinEmptyPair()
    1              0.000002     let extra = "\<Del>"
    1              0.000002   elseif s:is_space_expansion()
                                let extra = "\<Del>"
                              elseif s:is_cr_expansion()
                                let extra = repeat("\<Del>", len(matchstr(getline(line('.') + 1), '^\s*\S')))
                              else
    7              0.000008     let extra = ''
    7              0.000006   endif
    8              0.000018   return "\<BS>" . extra

FUNCTION  <SNR>102_CheckDefined()
Called 440 times
Total time:   0.010186
 Self time:   0.010186

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  440              0.001433   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  440              0.001426   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
  440              0.000917   for val in a:colors
  440              0.001143     if !empty(val) && val !=# 'NONE'
  440              0.000504       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  ale#command#FormatCommand()
Called 21 times
Total time:   0.003317
 Self time:   0.002196

count  total (s)   self (s)
   21              0.000037     let l:temporary_file = ''
   21              0.000031     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
   21              0.000128     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
   21              0.000069     if l:command =~# '%s'
   21              0.000646         let l:filename = fnamemodify(bufname(a:buffer), ':p')
   21   0.000830   0.000324         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
   21              0.000010     endif
                            
   21              0.000071     if l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
   20   0.000539   0.000147         let l:temporary_file = s:TemporaryFilename(a:buffer)
   20   0.000416   0.000193         let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
   20              0.000008     endif
                            
                                " Finish formatting so %% becomes %.
   21              0.000141     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
   21              0.000051     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
                                endif
                            
   21              0.000045     return [l:temporary_file, l:command]

FUNCTION  gitgutter#utility#getbufvar()
Called 80 times
Total time:   0.001191
 Self time:   0.001191

count  total (s)   self (s)
   80              0.000682   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
   80              0.000264   if has_key(dict, a:varname)
   80              0.000155     return dict[a:varname]
                              else
                                if a:0
                                  return a:1
                                endif
                              endif

FUNCTION  <SNR>131_OnTextChangedNormalMode()
Called 1 time
Total time:   0.000151
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000054   0.000005   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1   0.000095   0.000004   call s:OnFileReadyToParse()

FUNCTION  <SNR>97_ws_refresh()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000005   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
                                return
                              endif
    1              0.000007   unlet! b:airline_whitespace_check
    1              0.000002   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    1              0.000003   let b:airline_ws_changedtick = b:changedtick

FUNCTION  ale#sign#GetSignCommands()
Called 20 times
Total time:   0.011768
 Self time:   0.011768

count  total (s)   self (s)
   20              0.000070     let l:command_list = []
   20              0.000048     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
   20              0.000054     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
  379              0.000792     for [l:line_str, l:info] in items(a:sign_map)
  359              0.000293         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
  812              0.000812             for l:item in l:info.items
  456              0.000709                 let l:item.sign_id = l:info.new_id
  456              0.000595             endfor
                            
  356              0.000631             if index(l:info.current_id_list, l:info.new_id) < 0
    3              0.000024                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
    3              0.000001             endif
  356              0.000157         endif
  359              0.000233     endfor
                            
                                " Remove signs without new IDs.
  379              0.000441     for l:info in values(a:sign_map)
  715              0.000688         for l:current_id in l:info.current_id_list
  356              0.000394             if l:current_id isnot l:info.new_id
    3              0.000016                 call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
    3              0.000001             endif
  356              0.000277         endfor
  359              0.000582     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
   20              0.000044     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
   20              0.000025     return l:command_list

FUNCTION  ale_linters#python#pylint#GetCommand()
Called 1 time
Total time:   0.003638
 Self time:   0.000087

count  total (s)   self (s)
    1   0.000143   0.000043     let l:cd_string = ale#Var(a:buffer, 'python_pylint_change_directory')   ? ale#path#BufferCdString(a:buffer)   : ''
                            
    1   0.003407   0.000006     let l:executable = ale_linters#python#pylint#GetExecutable(a:buffer)
                            
    1              0.000014     let l:exec_args = l:executable =~? 'pipenv$'   ? ' run pylint'   : ''
                            
    1   0.000070   0.000020     return l:cd_string   . ale#Escape(l:executable) . l:exec_args   . ' ' . ale#Var(a:buffer, 'python_pylint_options')   . ' --output-format text --msg-template="{path}:{line}:{column}: {msg_id} ({symbol}) {msg}" --reports n'   . ' %s'

FUNCTION  <SNR>102_get_syn()
Called 1132 times
Total time:   0.031688
 Self time:   0.031688

count  total (s)   self (s)
 1132              0.003096   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 1132              0.001260   let color = ''
 1132              0.002802   if hlexists(a:group)
 1132              0.006384     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1132              0.000746   endif
 1132              0.002494   if empty(color) || color == -1
                                " should always exists
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
                                if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
                              endif
 1132              0.001990   return color

FUNCTION  airline#util#prepend()
Called 76 times
Total time:   0.000624
 Self time:   0.000624

count  total (s)   self (s)
   76              0.000219   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   76              0.000238   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>15_TriggerAbb()
Called 3 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    3              0.000042   if v:version < 703 || ( v:version == 703 && !has('patch489') ) || pumvisible()
    2              0.000006     return ''
                              endif
    1              0.000002   return "\<C-]>"

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 2 times
Total time:   0.000287
 Self time:   0.000190

count  total (s)   self (s)
    2              0.000006     if !g:ale_echo_cursor
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    2              0.000010     if mode() isnot# 'n'
                                    return
                                endif
                            
    2   0.000084   0.000056     call s:StopCursorTimer()
                            
    2              0.000016     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    2              0.000006     if l:pos != s:last_pos
    2   0.000107   0.000038         let l:delay = ale#Var(bufnr(''), 'echo_delay')
                            
    2              0.000015         let s:last_pos = l:pos
    2              0.000015         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    2              0.000003     endif

FUNCTION  <SNR>89_sync_active_winnr()
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000017   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  ale#util#LocItemCompare()
Called 936 times
Total time:   0.019509
 Self time:   0.017261

count  total (s)   self (s)
  936              0.001042     if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
  936              0.000957     if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
  936              0.000770     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
  936              0.000992     if a:left.lnum < a:right.lnum
  550              0.000361         return -1
                                endif
                            
  386              0.000395     if a:left.lnum > a:right.lnum
  278              0.000170         return 1
                                endif
                            
  108              0.000119     if a:left.col < a:right.col
                                    return -1
                                endif
                            
  108              0.000112     if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
  108              0.000332     if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
  108   0.001774   0.000614     let l:left_priority = ale#util#GetItemPriority(a:left)
  108   0.001472   0.000384     let l:right_priority = ale#util#GetItemPriority(a:right)
                            
  108              0.000153     if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
  108              0.000146     if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
  108              0.000079     return 0

FUNCTION  ale#job#Start()
Called 21 times
Total time:   0.030870
 Self time:   0.028123

count  total (s)   self (s)
   21   0.000279   0.000168     call ale#job#ValidateArguments(a:command, a:options)
                            
   21              0.000083     let l:job_info = copy(a:options)
   21              0.000028     let l:job_options = {}
                            
   21              0.000061     if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
                                else
   21              0.000093         let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
   21              0.000047         if has_key(a:options, 'out_cb')
   21              0.000092             let l:job_options.out_cb = function('s:VimOutputCallback')
   21              0.000013         endif
                            
   21              0.000037         if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
   21              0.000033         if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
   21              0.000077             let l:job_options.close_cb = function('s:VimCloseCallback')
   21              0.000089             let l:job_options.exit_cb = function('s:VimExitCallback')
   21              0.000009         endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
   21              0.023998         let l:job_info.job = job_start(a:command, l:job_options)
   21   0.004458   0.001822         let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
   21              0.000116     endif
                            
   21              0.000041     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
   21              0.000192         let s:job_map[l:job_id] = l:job_info
   21              0.000017     endif
                            
   21              0.000037     return l:job_id

FUNCTION  <SNR>94_is_branch_empty()
Called 76 times
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
   76              0.000423   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  airline#extensions#ale#get_warning()
Called 76 times
Total time:   0.014504
 Self time:   0.000583

count  total (s)   self (s)
   76   0.014462   0.000541   return airline#extensions#ale#get('warning')

FUNCTION  <SNR>102_hl_group_exists()
Called 332 times
Total time:   0.003541
 Self time:   0.003541

count  total (s)   self (s)
  332              0.000852   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  332              0.000269   return 1

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   21   0.479496   0.002059  <SNR>124_VimCloseCallback()
   41   0.473831   0.002879  <SNR>119_HandleExit()
   21   0.456174   0.001652  <SNR>124_VimExitCallback()
   20   0.439304   0.003390  ale#engine#HandleLoclist()
   20   0.405786   0.003689  ale#engine#SetResults()
   86   0.358699   0.004773  ale#CallWithCooldown()
   20   0.351164   0.225960  ale#sign#SetSigns()
   20   0.306670   0.001491  ale#Lint()
   20   0.302321   0.002313  <SNR>108_ALELintImpl()
   20   0.285075   0.006007  ale#engine#RunLinters()
   21   0.274690   0.003168  <SNR>119_RunLinter()
   21   0.179123   0.003164  <SNR>119_InvokeChain()
   42   0.161744   0.001893  ale#python#FindExecutable()
   42   0.157534   0.087961  ale#python#FindVirtualenv()
   40   0.154572   0.000470  ale_linters#python#mypy#GetExecutable()
   76   0.142274   0.007498  airline#check_mode()
    5   0.132536   0.017115  airline#highlighter#highlight()
   41   0.122143   0.017084  <SNR>131_OnTextChangedInsertMode()
  440   0.100612   0.031348  airline#highlighter#exec()
   21   0.095922   0.001688  ale#engine#ProcessChain()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   20   0.351164   0.225960  ale#sign#SetSigns()
   42   0.157534   0.087961  ale#python#FindVirtualenv()
   20              0.061705  ale#sign#ParseSigns()
 4184              0.054241  ale#path#Simplify()
   85              0.045261  <SNR>70_Highlight_Matching_Pair()
  189              0.042639  <SNR>131_Pyeval()
    1              0.033659  <SNR>97_check_mixed_indent()
   34   0.042341   0.032044  <SNR>131_InvokeCompletion()
 1132              0.031688  <SNR>102_get_syn()
  440   0.100612   0.031348  airline#highlighter#exec()
   41              0.030184  <SNR>131_InsideCommentOrString()
  459              0.029299  ale#GetLocItemMessage()
   76   0.064324   0.029101  airline#extensions#whitespace#check()
   21   0.030870   0.028123  ale#job#Start()
  566   0.064725   0.027847  airline#highlighter#get_highlight()
  120   0.026641   0.023750  ale#path#Upwards()
   20              0.020208  ale#util#Writefile()
   20   0.036896   0.019976  <SNR>136_BuildSignMap()
   39   0.027578   0.019135  ale#python#FindProjectRootIni()
   63   0.027075   0.018633  ale#linter#Get()

